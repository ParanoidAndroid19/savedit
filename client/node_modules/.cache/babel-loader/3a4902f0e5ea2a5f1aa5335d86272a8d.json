{"ast":null,"code":"'use strict';\n\nvar handlers;\n\nvar wrap = function (target) {\n  if (typeof target === 'object' && target && typeof target.then === 'function' && typeof Proxy !== 'undefined') {\n    // The target needs to be stored internally as a function, so that it can use the `apply` and `construct` handlers.\n    var targetFunc = function () {\n      return target;\n    };\n\n    targetFunc._promise_chain_cache = Object.create(null);\n    return new Proxy(targetFunc, handlers);\n  }\n\n  return target;\n};\n\nif (typeof Proxy !== 'undefined') {\n  if (typeof Reflect === 'undefined') {\n    require('harmony-reflect');\n  }\n\n  handlers = {\n    get: function (target, property) {\n      if (property === 'inspect') {\n        return function () {\n          return '[chainable Promise]';\n        };\n      }\n\n      if (property === '_raw') {\n        return target();\n      }\n\n      if (typeof property === 'symbol') {\n        return target()[property];\n      } // If the Promise itself has the property ('then', 'catch', etc.), return the property itself, bound to the target.\n      // However, wrap the result of calling this function. This allows wrappedPromise.then(something) to also be wrapped.\n\n\n      if (property in target()) {\n        if (property !== 'constructor' && !property.startsWith('_') && typeof target()[property] === 'function') {\n          return function () {\n            return wrap(target()[property].apply(target(), arguments));\n          };\n        }\n\n        return target()[property];\n      } // If the property has a value in the cache, use that value.\n\n\n      if (Object.prototype.hasOwnProperty.call(target._promise_chain_cache, property)) {\n        return target._promise_chain_cache[property];\n      } // If the Promise library allows synchronous inspection (bluebird, etc.), ensure that properties of resolved\n      // Promises are also resolved immediately.\n\n\n      if (target().isFulfilled && target().isFulfilled() && typeof target().value === 'function') {\n        return wrap(target().constructor.resolve(target().value()[property]));\n      } // Otherwise, return a promise for that property.\n      // Store it in the cache so that subsequent references to that property will return the same promise.\n\n\n      target._promise_chain_cache[property] = wrap(target().then(function (result) {\n        if (result && (typeof result === 'object' || typeof result === 'function')) {\n          return wrap(result[property]);\n        }\n\n        throw new TypeError(\"Promise chain rejection: Cannot read property '\" + property + \"' of \" + result + '.');\n      }));\n      return target._promise_chain_cache[property];\n    },\n    apply: function (target, thisArg, args) {\n      // If the wrapped Promise is called, return a Promise that calls the result\n      return wrap(target().constructor.all([target(), thisArg]).then(function (results) {\n        if (typeof results[0] === 'function') {\n          return wrap(Reflect.apply(results[0], results[1], args));\n        }\n\n        throw new TypeError('Promise chain rejection: Attempted to call ' + results[0] + ' which is not a function.');\n      }));\n    },\n    construct: function (target, args) {\n      return wrap(target().then(function (result) {\n        return wrap(Reflect.construct(result, args));\n      }));\n    }\n  }; // Make sure all other references to the proxied object refer to the promise itself, not the function wrapping it\n\n  Object.getOwnPropertyNames(Reflect).forEach(function (handler) {\n    handlers[handler] = handlers[handler] || function (target, arg1, arg2, arg3) {\n      return Reflect[handler](target(), arg1, arg2, arg3);\n    };\n  });\n}\n\nmodule.exports = wrap;","map":{"version":3,"sources":["/Users/simranbhake/Desktop/ProjectProgress/8. savedit/node_modules/promise-chains/index.js"],"names":["handlers","wrap","target","then","Proxy","targetFunc","_promise_chain_cache","Object","create","Reflect","require","get","property","startsWith","apply","arguments","prototype","hasOwnProperty","call","isFulfilled","value","constructor","resolve","result","TypeError","thisArg","args","all","results","construct","getOwnPropertyNames","forEach","handler","arg1","arg2","arg3","module","exports"],"mappings":"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","sourcesContent":["'use strict';\nvar handlers;\n\nvar wrap = function (target) {\n  if (typeof target === 'object' && target && typeof target.then === 'function' && typeof Proxy !== 'undefined') {\n    // The target needs to be stored internally as a function, so that it can use the `apply` and `construct` handlers.\n    var targetFunc = function () {\n      return target;\n    };\n    targetFunc._promise_chain_cache = Object.create(null);\n    return new Proxy(targetFunc, handlers);\n  }\n  return target;\n};\n\nif (typeof Proxy !== 'undefined') {\n  if (typeof Reflect === 'undefined') {\n    require('harmony-reflect');\n  }\n  handlers = {\n    get: function (target, property) {\n      if (property === 'inspect') {\n        return function () {\n          return '[chainable Promise]';\n        };\n      }\n      if (property === '_raw') {\n        return target();\n      }\n      if (typeof property === 'symbol') {\n        return target()[property];\n      }\n      // If the Promise itself has the property ('then', 'catch', etc.), return the property itself, bound to the target.\n      // However, wrap the result of calling this function. This allows wrappedPromise.then(something) to also be wrapped.\n      if (property in target()) {\n        if (property !== 'constructor' && !property.startsWith('_') && typeof target()[property] === 'function') {\n          return function () {\n            return wrap(target()[property].apply(target(), arguments));\n          };\n        }\n        return target()[property];\n      }\n      // If the property has a value in the cache, use that value.\n      if (Object.prototype.hasOwnProperty.call(target._promise_chain_cache, property)) {\n        return target._promise_chain_cache[property];\n      }\n      // If the Promise library allows synchronous inspection (bluebird, etc.), ensure that properties of resolved\n      // Promises are also resolved immediately.\n      if (target().isFulfilled && target().isFulfilled() && typeof target().value === 'function') {\n        return wrap(target().constructor.resolve(target().value()[property]));\n      }\n      // Otherwise, return a promise for that property.\n      // Store it in the cache so that subsequent references to that property will return the same promise.\n      target._promise_chain_cache[property] = wrap(target().then(function (result) {\n        if (result && (typeof result === 'object' || typeof result === 'function')) {\n          return wrap(result[property]);\n        }\n        throw new TypeError(\"Promise chain rejection: Cannot read property '\" + property + \"' of \" + result + '.');\n      }));\n      return target._promise_chain_cache[property];\n    },\n    apply: function (target, thisArg, args) {\n      // If the wrapped Promise is called, return a Promise that calls the result\n      return wrap(target().constructor.all([target(), thisArg]).then(function (results) {\n        if (typeof results[0] === 'function') {\n          return wrap(Reflect.apply(results[0], results[1], args));\n        }\n        throw new TypeError('Promise chain rejection: Attempted to call ' + results[0] + ' which is not a function.');\n      }));\n    },\n    construct: function (target, args) {\n      return wrap(target().then(function (result) {\n        return wrap(Reflect.construct(result, args));\n      }));\n    }\n  };\n\n  // Make sure all other references to the proxied object refer to the promise itself, not the function wrapping it\n  Object.getOwnPropertyNames(Reflect).forEach(function (handler) {\n    handlers[handler] = handlers[handler] || function (target, arg1, arg2, arg3) {\n      return Reflect[handler](target(), arg1, arg2, arg3);\n    };\n  });\n}\n\nmodule.exports = wrap;\n"]},"metadata":{},"sourceType":"script"}