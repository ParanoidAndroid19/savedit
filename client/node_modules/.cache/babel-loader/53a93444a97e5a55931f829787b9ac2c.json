{"ast":null,"code":"\"use strict\";\n\nvar _lodash = require(\"lodash\");\n\nvar _Promise = _interopRequireDefault(require(\"./Promise.js\"));\n\nvar _promiseChains = _interopRequireDefault(require(\"promise-chains\"));\n\nvar _util = _interopRequireDefault(require(\"util\"));\n\nvar requestHandler = _interopRequireWildcard(require(\"./request_handler.js\"));\n\nvar _constants = require(\"./constants.js\");\n\nvar errors = _interopRequireWildcard(require(\"./errors.js\"));\n\nvar _helpers = require(\"./helpers.js\");\n\nvar _create_config = _interopRequireDefault(require(\"./create_config.js\"));\n\nvar objects = _interopRequireWildcard(require(\"./objects/index.js\"));\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  } else {\n    var newObj = {};\n\n    if (obj != null) {\n      for (var key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key)) {\n          var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};\n\n          if (desc.get || desc.set) {\n            Object.defineProperty(newObj, key, desc);\n          } else {\n            newObj[key] = obj[key];\n          }\n        }\n      }\n    }\n\n    newObj.default = obj;\n    return newObj;\n  }\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar api_type = 'json';\n/** The class for a snoowrap requester.\n * A requester is the base object that is used to fetch content from reddit. Each requester contains a single set of OAuth\n tokens.\n\n If constructed with a refresh token, a requester will be able to repeatedly generate access tokens as necessary, without any\n further user intervention. After making at least one request, a requester will have the `access_token` property, which specifies\n the access token currently in use. It will also have a few additional properties such as `scope` (an array of scope strings)\n and `ratelimitRemaining` (the number of requests remaining for the current 10-minute interval, in compliance with reddit's\n [API rules](https://github.com/reddit/reddit/wiki/API).) These properties primarily exist for internal use, but they are\n exposed since they are useful externally as well.\n */\n\nvar snoowrap = class snoowrap {\n  /**\n   * @summary Constructs a new requester.\n   * @desc You should use the snoowrap constructor if you are able to authorize a reddit account in advance (e.g. for a Node.js\n   script that always uses the same account). If you aren't able to authorize in advance (e.g. acting through an arbitrary user's\n   account while running snoowrap in a browser), then you should use {@link snoowrap.getAuthUrl} and\n   {@link snoowrap.fromAuthCode} instead.\n   *\n   * To edit snoowrap specific settings, see {@link snoowrap#config}.\n   *\n   * snoowrap supports several different options for pre-existing authentication:\n   * 1. *Refresh token*: To authenticate with a refresh token, pass an object with the properties `userAgent`, `clientId`,\n   `clientSecret`, and `refreshToken` to the snoowrap constructor. You will need to get the refresh token from reddit\n   beforehand. A script to automatically generate refresh tokens for you can be found\n   [here](https://github.com/not-an-aardvark/reddit-oauth-helper).\n   * 1. *Username/password*: To authenticate with a username and password, pass an object with the properties `userAgent`,\n   `clientId`, `clientSecret`, `username`, and `password` to the snoowrap constructor. Note that username/password\n   authentication is only possible for `script`-type apps.\n   * 1. *Access token*: To authenticate with an access token, pass an object with the properties `userAgent` and `accessToken`\n   to the snoowrap constructor. Note that all access tokens expire one hour after being generated, so this method is\n   not recommended for long-term use.\n   * @param {object} options An object containing authentication options. This should always have the property `userAgent`. It\n   must also contain some combination of credentials (see above)\n   * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n   is running in a browser.\n   * @param {string} [options.clientId] The client ID of your app (assigned by reddit)\n   * @param {string} [options.clientSecret] The client secret of your app (assigned by reddit). If you are using a refresh token\n   with an installed app (which does not have a client secret), pass an empty string as your `clientSecret`.\n   * @param {string} [options.username] The username of the account to access\n   * @param {string} [options.password] The password of the account to access\n   * @param {string} [options.refreshToken] A refresh token for your app\n   * @param {string} [options.accessToken] An access token for your app\n   */\n  constructor() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        user_agent = _ref.user_agent,\n        _ref$userAgent = _ref.userAgent,\n        userAgent = _ref$userAgent === void 0 ? user_agent : _ref$userAgent,\n        client_id = _ref.client_id,\n        _ref$clientId = _ref.clientId,\n        clientId = _ref$clientId === void 0 ? client_id : _ref$clientId,\n        client_secret = _ref.client_secret,\n        _ref$clientSecret = _ref.clientSecret,\n        clientSecret = _ref$clientSecret === void 0 ? client_secret : _ref$clientSecret,\n        refresh_token = _ref.refresh_token,\n        _ref$refreshToken = _ref.refreshToken,\n        refreshToken = _ref$refreshToken === void 0 ? refresh_token : _ref$refreshToken,\n        access_token = _ref.access_token,\n        _ref$accessToken = _ref.accessToken,\n        accessToken = _ref$accessToken === void 0 ? access_token : _ref$accessToken,\n        username = _ref.username,\n        password = _ref.password;\n\n    if (!userAgent && !_helpers.isBrowser) {\n      return (0, _helpers.requiredArg)('userAgent');\n    }\n\n    if ((!accessToken || typeof accessToken !== 'string') && (clientId === undefined || clientSecret === undefined || typeof refreshToken !== 'string') && (clientId === undefined || clientSecret === undefined || username === undefined || password === undefined)) {\n      throw new errors.NoCredentialsError();\n    }\n\n    if (_helpers.isBrowser) {\n      this.userAgent = global.navigator.userAgent;\n    }\n\n    (0, _lodash.defaults)(this, {\n      userAgent,\n      clientId,\n      clientSecret,\n      refreshToken,\n      accessToken,\n      username,\n      password\n    }, {\n      clientId: null,\n      clientSecret: null,\n      refreshToken: null,\n      accessToken: null,\n      username: null,\n      password: null,\n      ratelimitRemaining: null,\n      ratelimitExpiration: null,\n      tokenExpiration: null,\n      scope: null,\n      _config: (0, _create_config.default)(),\n      _nextRequestTimestamp: -Infinity\n    });\n    (0, _helpers.addSnakeCaseShadowProps)(this);\n  }\n  /**\n   * @summary Gets an authorization URL, which allows a user to authorize access to their account\n   * @desc This create a URL where a user can authorize an app to act through their account. If the user visits the returned URL\n   in a web browser, they will see a page that looks like [this](https://i.gyazo.com/0325534f38b78c1dbd4c84d690dda6c2.png). If\n   the user clicks \"Allow\", they will be redirected to your `redirectUri`, with a `code` querystring parameter containing an\n   * *authorization code*. If this code is passed to {@link snoowrap.fromAuthCode}, you can create a requester to make\n   requests on behalf of the user.\n   *\n   * The main use-case here is for running snoowrap in a browser. You can generate a URL, send the user there, and then continue\n   after the user authenticates on reddit and is redirected back.\n   *\n   * @param {object} options\n   * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n   browser, using an \"Installed\" app type is recommended.\n   * @param {string[]} options.scope An array of scopes (permissions on the user's account) to request on the authentication\n   page. A list of possible scopes can be found [here](https://www.reddit.com/api/v1/scopes). You can also get them on-the-fly\n   with {@link snoowrap#getOauthScopeList}.\n   * @param {string} options.redirectUri The URL where the user should be redirected after authenticating. This **must** be the\n   same as the redirect URI that is configured for the reddit app. (If there is a mismatch, the returned URL will display an\n   error page instead of an authentication form.)\n   * @param {boolean} [options.permanent=true] If `true`, the app will have indefinite access to the user's account. If `false`,\n   access to the user's account will expire after 1 hour.\n   * @param {string} [options.state] A string that can be used to verify a user after they are redirected back to the site. When\n   the user is redirected from reddit, to the redirect URI after authenticating, the resulting URI will have this same `state`\n   value in the querystring. (See [here](http://www.twobotechnologies.com/blog/2014/02/importance-of-state-in-oauth2.html) for\n   more information on how to use the `state` value.)\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain for the URL. If the user is authenticating on\n   reddit.com (as opposed to some other site with a reddit-like API), you can omit this value.\n   * @returns {string} A URL where the user can authenticate with the given options\n   * @example\n   *\n   * var authenticationUrl = snoowrap.getAuthUrl({\n   *   clientId: 'foobarbazquuux',\n   *   scope: ['identity', 'wikiread', 'wikiedit'],\n   *   redirectUri: 'https://example.com/reddit_callback',\n   *   permanent: false,\n   *   state: 'fe211bebc52eb3da9bef8db6e63104d3' // a random string, this could be validated when the user is redirected back\n   * });\n   * // --> 'https://www.reddit.com/api/v1/authorize?client_id=foobarbaz&response_type=code&state= ...'\n   *\n   * window.location = authenticationUrl; // send the user to the authentication url\n   */\n\n\n  static getAuthUrl(_ref2) {\n    var _ref2$clientId = _ref2.clientId,\n        clientId = _ref2$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref2$clientId,\n        _ref2$scope = _ref2.scope,\n        scope = _ref2$scope === void 0 ? (0, _helpers.requiredArg)('scope') : _ref2$scope,\n        _ref2$redirectUri = _ref2.redirectUri,\n        redirectUri = _ref2$redirectUri === void 0 ? (0, _helpers.requiredArg)('redirectUri') : _ref2$redirectUri,\n        _ref2$permanent = _ref2.permanent,\n        permanent = _ref2$permanent === void 0 ? true : _ref2$permanent,\n        _ref2$state = _ref2.state,\n        state = _ref2$state === void 0 ? '_' : _ref2$state,\n        _ref2$endpointDomain = _ref2.endpointDomain,\n        endpointDomain = _ref2$endpointDomain === void 0 ? 'reddit.com' : _ref2$endpointDomain;\n\n    if (!(Array.isArray(scope) && scope.length && scope.every(function (scopeValue) {\n      return scopeValue && typeof scopeValue === 'string';\n    }))) {\n      throw new TypeError('Missing `scope` argument; a non-empty list of OAuth scopes must be provided');\n    }\n\n    return \"\\n      https://www.\".concat(endpointDomain, \"/api/v1/authorize?\\n      client_id=\").concat(encodeURIComponent(clientId), \"\\n      &response_type=code\\n      &state=\").concat(encodeURIComponent(state), \"\\n      &redirect_uri=\").concat(encodeURIComponent(redirectUri), \"\\n      &duration=\").concat(permanent ? 'permanent' : 'temporary', \"\\n      &scope=\").concat(encodeURIComponent(scope.join(' ')), \"\\n    \").replace(/\\s/g, '');\n  }\n  /**\n   * @summary Creates a snoowrap requester from an authorization code.\n   * @desc An authorization code is the `code` value that appears in the querystring after a user authenticates with reddit and\n   is redirected. For more information, see {@link snoowrap.getAuthUrl}.\n   *\n   * The main use-case for this function is for running snoowrap in a browser. You can generate a URL with\n   {@link snoowrap.getAuthUrl} and send the user to that URL, and then use this function to create a requester when\n   the user is redirected back with an authorization code.\n   * @param {object} options\n   * @param {string} options.code The authorization code\n   * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n   is running in a browser.\n   * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n   browser, using an \"Installed\" app type is recommended.\n   * @param {string} [options.clientSecret] The client secret of your app. If your app has the \"Installed\" app type, omit\n   this parameter.\n   * @param {string} options.redirectUri The redirect URI that is configured for the reddit app.\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain that the returned requester should be configured\n   to use. If the user is authenticating on reddit.com (as opposed to some other site with a reddit-like API), you can omit this\n   value.\n   * @returns {Promise<snoowrap>} A Promise that fulfills with a `snoowrap` instance\n   * @example\n   *\n   * // Get the `code` querystring param (assuming the user was redirected from reddit)\n   * var code = new URL(window.location.href).searchParams.get('code');\n   *\n   * snoowrap.fromAuthCode({\n   *   code: code,\n   *   userAgent: 'My app',\n   *   clientId: 'foobarbazquuux',\n   *   redirectUri: 'example.com'\n   * }).then(r => {\n   *   // Now we have a requester that can access reddit through the user's account\n   *   return r.getHot().then(posts => {\n   *     // do something with posts from the front page\n   *   });\n   * })\n   */\n\n\n  static fromAuthCode(_ref3) {\n    var _this = this;\n\n    var _ref3$code = _ref3.code,\n        code = _ref3$code === void 0 ? (0, _helpers.requiredArg)('code') : _ref3$code,\n        _ref3$userAgent = _ref3.userAgent,\n        userAgent = _ref3$userAgent === void 0 ? _helpers.isBrowser ? global.navigator.userAgent : (0, _helpers.requiredArg)('userAgent') : _ref3$userAgent,\n        _ref3$clientId = _ref3.clientId,\n        clientId = _ref3$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref3$clientId,\n        clientSecret = _ref3.clientSecret,\n        _ref3$redirectUri = _ref3.redirectUri,\n        redirectUri = _ref3$redirectUri === void 0 ? (0, _helpers.requiredArg)('redirectUri') : _ref3$redirectUri,\n        _ref3$endpointDomain = _ref3.endpointDomain,\n        endpointDomain = _ref3$endpointDomain === void 0 ? 'reddit.com' : _ref3$endpointDomain;\n    return this.prototype.credentialedClientRequest.call({\n      userAgent,\n      clientId,\n      clientSecret,\n      // Use `this.prototype.rawRequest` function to allow for custom `rawRequest` method usage in subclasses.\n      rawRequest: this.prototype.rawRequest\n    }, {\n      method: 'post',\n      baseUrl: \"https://www.\".concat(endpointDomain, \"/\"),\n      uri: 'api/v1/access_token',\n      form: {\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: redirectUri\n      }\n    }).then(function (response) {\n      if (response.error) {\n        throw new errors.RequestError(\"API Error: \".concat(response.error, \" - \").concat(response.error_description));\n      } // Use `new this` instead of `new snoowrap` to ensure that subclass instances can be returned\n\n\n      var requester = new _this(_objectSpread({\n        userAgent,\n        clientId,\n        clientSecret\n      }, response));\n      requester.config({\n        endpointDomain\n      });\n      return requester;\n    });\n  }\n  /**\n   * @summary Returns the grant types available for app-only authentication\n   * @desc Per the Reddit API OAuth docs, there are two different grant types depending on whether the app is an installed client\n   * or a confidential client such as a web app or string. This getter returns the possible values for the \"grant_type\" field\n   * in application-only auth.\n   * @returns {object} The enumeration of possible grant_type values\n   */\n\n\n  static get grantType() {\n    return {\n      CLIENT_CREDENTIALS: 'client_credentials',\n      INSTALLED_CLIENT: 'https://oauth.reddit.com/grants/installed_client'\n    };\n  }\n  /**\n  * @summary Creates a snoowrap requester from a \"user-less\" Authorization token\n  * @desc In some cases, 3rd party app clients may wish to make API requests without a user context. App clients can request\n  * a \"user-less\" Authorization token via either the standard client_credentials grant, or the reddit specific\n  * extension to this grant, https://oauth.reddit.com/grants/installed_client. Which grant type an app uses depends on\n  * the app-type and its use case.\n  * @param {object} options\n  * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n  is running in a browser.\n  * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n  * browser, using an \"Installed\" app type is recommended.\n  * @param {string} [options.clientSecret] The client secret of your app. Only required for \"client_credentials\" grant type.\n  * @param {string} [options.deviceId] A unique, per-device ID generated by your client. Only required\n  * for \"Installed\" grant type, needs to be between 20-30 characters long. From the reddit docs: \"reddit *may* choose to use\n  * this ID to generate aggregate data about user counts. Clients that wish to remain anonymous should use the value\n  * DO_NOT_TRACK_THIS_DEVICE.\"\n  * @param {string} [options.grantType=snoowrap.grantType.INSTALLED_CLIENT] The type of \"user-less\"\n  * token to use {@link snoowrap.grantType}\n  * @param {boolean} [options.permanent=true] If `true`, the app will have indefinite access. If `false`,\n  access will expire after 1 hour.\n  * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain that the returned requester should be configured\n  to use. If the user is authenticating on reddit.com (as opposed to some other site with a reddit-like API), you can omit this\n  value.\n  * @returns {Promise<snoowrap>} A Promise that fulfills with a `snoowrap` instance\n  * @example\n  *\n  * snoowrap.fromApplicationOnlyAuth({\n  *   userAgent: 'My app',\n  *   clientId: 'foobarbazquuux',\n  *   deviceId: 'unique id between 20-30 chars'\n  *   grantType: snoowrap.grantType.INSTALLED_CLIENT\n  * }).then(r => {\n  *   // Now we have a requester that can access reddit through a \"user-less\" Auth token\n  *   return r.getHot().then(posts => {\n  *     // do something with posts from the front page\n  *   });\n  * })\n  *\n  * snoowrap.fromApplicationOnlyAuth({\n  *   userAgent: 'My app',\n  *   clientId: 'foobarbazquuux',\n  *   clientSecret: 'your web app secret'\n  *   grantType: snoowrap.grantType.CLIENT_CREDENTIALS\n  * }).then(r => {\n  *   // Now we have a requester that can access reddit through a \"user-less\" Auth token\n  *   return r.getHot().then(posts => {\n  *     // do something with posts from the front page\n  *   });\n  * })\n  */\n\n\n  static fromApplicationOnlyAuth(_ref4) {\n    var _this2 = this;\n\n    var _ref4$userAgent = _ref4.userAgent,\n        userAgent = _ref4$userAgent === void 0 ? _helpers.isBrowser ? global.navigator.userAgent : (0, _helpers.requiredArg)('userAgent') : _ref4$userAgent,\n        _ref4$clientId = _ref4.clientId,\n        clientId = _ref4$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref4$clientId,\n        clientSecret = _ref4.clientSecret,\n        deviceId = _ref4.deviceId,\n        _ref4$grantType = _ref4.grantType,\n        grantType = _ref4$grantType === void 0 ? snoowrap.grantType.INSTALLED_CLIENT : _ref4$grantType,\n        _ref4$permanent = _ref4.permanent,\n        permanent = _ref4$permanent === void 0 ? true : _ref4$permanent,\n        _ref4$endpointDomain = _ref4.endpointDomain,\n        endpointDomain = _ref4$endpointDomain === void 0 ? 'reddit.com' : _ref4$endpointDomain;\n    return this.prototype.credentialedClientRequest.call({\n      clientId,\n      clientSecret,\n      // Use `this.prototype.rawRequest` function to allow for custom `rawRequest` method usage in subclasses.\n      rawRequest: this.prototype.rawRequest\n    }, {\n      method: 'post',\n      baseUrl: \"https://www.\".concat(endpointDomain, \"/\"),\n      uri: 'api/v1/access_token',\n      form: {\n        grant_type: grantType,\n        device_id: deviceId,\n        duration: permanent ? 'permanent' : 'temporary'\n      }\n    }).then(function (response) {\n      if (response.error) {\n        throw new errors.RequestError(\"API Error: \".concat(response.error, \" - \").concat(response.error_description));\n      } // Use `new this` instead of `new snoowrap` to ensure that subclass instances can be returned\n\n\n      var requester = new _this2(_objectSpread({\n        userAgent,\n        clientId,\n        clientSecret\n      }, response));\n      requester.config({\n        endpointDomain\n      });\n      return requester;\n    });\n  }\n\n  _newObject(objectType, content) {\n    var _hasFetched = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    return Array.isArray(content) ? content : new snoowrap.objects[objectType](content, this, _hasFetched);\n  }\n  /**\n   * @summary Retrieves or modifies the configuration options for this snoowrap instance.\n   * @param {object} [options] A map of `{[config property name]: value}`. Note that any omitted config properties will simply\n   retain whatever value they had previously. (In other words, if you only want to change one property, you only need to put\n   that one property in this parameter. To get the current configuration without modifying anything, simply omit this\n   parameter.)\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint where requests should be sent\n   * @param {Number} [options.requestDelay=0] A minimum delay, in milliseconds, to enforce between API calls. If multiple\n   api calls are requested during this timespan, they will be queued and sent one at a time. Setting this to more than 1000 will\n   ensure that reddit's ratelimit is never reached, but it will make things run slower than necessary if only a few requests\n   are being sent. If this is set to zero, snoowrap will not enforce any delay between individual requests. However, it will\n   still refuse to continue if reddit's enforced ratelimit (600 requests per 10 minutes) is exceeded.\n   * @param {Number} [options.requestTimeout=30000] A timeout for all OAuth requests, in milliseconds. If the reddit server\n   fails to return a response within this amount of time, the Promise will be rejected with a timeout error.\n   * @param {boolean} [options.continueAfterRatelimitError=false] Determines whether snoowrap should queue API calls if\n   reddit's ratelimit is exceeded. If set to `true` when the ratelimit is exceeded, snoowrap will queue all further requests,\n   and will attempt to send them again after the current ratelimit period expires (which happens every 10 minutes). If set\n   to `false`, snoowrap will simply throw an error when reddit's ratelimit is exceeded.\n   * @param {Number[]} [options.retryErrorCodes=[502, 503, 504, 522]] If reddit responds to an idempotent request with one of\n   these error codes, snoowrap will retry the request, up to a maximum of `max_retry_attempts` requests in total. (These\n   errors usually indicate that there was an temporary issue on reddit's end, and retrying the request has a decent chance of\n   success.) This behavior can be disabled by simply setting this property to an empty array.\n   * @param {Number} [options.maxRetryAttempts=3] See `retryErrorCodes`.\n   * @param {boolean} [options.warnings=true] snoowrap may occasionally log warnings, such as deprecation notices, to the\n   console. These can be disabled by setting this to `false`.\n   * @param {boolean} [options.debug=false] If set to true, snoowrap will print out potentially-useful information for debugging\n   purposes as it runs.\n   * @param {boolean} [options.proxies=true] Setting this to `false` disables snoowrap's method-chaining feature. This causes\n   the syntax for using snoowrap to become a bit heavier, but allows for consistency between environments that support the ES6\n   `Proxy` object and environments that don't. This option is a no-op in environments that don't support the `Proxy` object,\n   since method chaining is always disabled in those environments. Note, changing this setting must be done before making\n   any requests.\n   * @returns {object} An updated Object containing all of the configuration values\n   * @example\n   *\n   * r.config({requestDelay: 1000, warnings: false});\n   * // sets the request delay to 1000 milliseconds, and suppresses warnings.\n   */\n\n\n  config() {\n    var _this3 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var invalidKey = Object.keys(options).find(function (key) {\n      return !(key in _this3._config);\n    });\n\n    if (invalidKey) {\n      throw new TypeError(\"Invalid config option '\".concat(invalidKey, \"'\"));\n    }\n\n    return Object.assign(this._config, options);\n  }\n\n  _warn() {\n    if (this._config.warnings) {\n      var _console;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_console = console).warn.apply(_console, ['[warning]'].concat(args)); // eslint-disable-line no-console\n\n    }\n  }\n\n  _debug() {\n    if (this._config.debug) {\n      var _console2;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      (_console2 = console).log.apply(_console2, ['[debug]'].concat(args)); // eslint-disable-line no-console\n\n    }\n  }\n\n  get _promiseWrap() {\n    return this._config.proxies ? _promiseChains.default : identity;\n  }\n  /**\n   * @summary Gets information on a reddit user with a given name.\n   * @param {string} name - The user's username\n   * @returns {RedditUser} An unfetched RedditUser object for the requested user\n   * @example\n   *\n   * r.getUser('not_an_aardvark')\n   * // => RedditUser { name: 'not_an_aardvark' }\n   * r.getUser('not_an_aardvark').link_karma.then(console.log)\n   * // => 6\n   */\n\n\n  getUser(name) {\n    return this._newObject('RedditUser', {\n      name: (name + '').replace(/^\\/?u\\//, '')\n    });\n  }\n  /**\n   * @summary Gets information on a comment with a given id.\n   * @param {string} commentId - The base36 id of the comment\n   * @returns {Comment} An unfetched Comment object for the requested comment\n   * @example\n   *\n   * r.getComment('c0b6xx0')\n   * // => Comment { name: 't1_c0b6xx0' }\n   * r.getComment('c0b6xx0').author.name.then(console.log)\n   * // => 'Kharos'\n   */\n\n\n  getComment(commentId) {\n    return this._newObject('Comment', {\n      name: (0, _helpers.addFullnamePrefix)(commentId, 't1_')\n    });\n  }\n  /**\n   * @summary Gets information on a given subreddit.\n   * @param {string} displayName - The name of the subreddit (e.g. 'AskReddit')\n   * @returns {Subreddit} An unfetched Subreddit object for the requested subreddit\n   * @example\n   *\n   * r.getSubreddit('AskReddit')\n   * // => Subreddit { display_name: 'AskReddit' }\n   * r.getSubreddit('AskReddit').created_utc.then(console.log)\n   * // => 1201233135\n   */\n\n\n  getSubreddit(displayName) {\n    return this._newObject('Subreddit', {\n      display_name: displayName.replace(/^\\/?r\\//, '')\n    });\n  }\n  /**\n   * @summary Gets information on a given submission.\n   * @param {string} submissionId - The base36 id of the submission\n   * @returns {Submission} An unfetched Submission object for the requested submission\n   * @example\n   *\n   * r.getSubmission('2np694')\n   * // => Submission { name: 't3_2np694' }\n   * r.getSubmission('2np694').title.then(console.log)\n   * // => 'What tasty food would be distusting if eaten over rice?'\n   */\n\n\n  getSubmission(submissionId) {\n    return this._newObject('Submission', {\n      name: (0, _helpers.addFullnamePrefix)(submissionId, 't3_')\n    });\n  }\n  /**\n   * @summary Gets a private message by ID.\n   * @param {string} messageId The base36 ID of the message\n   * @returns {PrivateMessage} An unfetched PrivateMessage object for the requested message\n   * @example\n   *\n   * r.getMessage('51shnw')\n   * // => PrivateMessage { name: 't4_51shnw' }\n   * r.getMessage('51shnw').subject.then(console.log)\n   * // => 'Example'\n   * // See here for a screenshot of the PM in question https://i.gyazo.com/24f3b97e55b6ff8e3a74cb026a58b167.png\n   */\n\n\n  getMessage(messageId) {\n    return this._newObject('PrivateMessage', {\n      name: (0, _helpers.addFullnamePrefix)(messageId, 't4_')\n    });\n  }\n  /**\n   * Gets a livethread by ID.\n   * @param {string} threadId The base36 ID of the livethread\n   * @returns {LiveThread} An unfetched LiveThread object\n   * @example\n   *\n   * r.getLivethread('whrdxo8dg9n0')\n   * // => LiveThread { id: 'whrdxo8dg9n0' }\n   * r.getLivethread('whrdxo8dg9n0').nsfw.then(console.log)\n   * // => false\n   */\n\n\n  getLivethread(threadId) {\n    return this._newObject('LiveThread', {\n      id: (0, _helpers.addFullnamePrefix)(threadId, 'LiveUpdateEvent_').slice(16)\n    });\n  }\n  /**\n   * @summary Gets information on the requester's own user profile.\n   * @returns {RedditUser} A RedditUser object corresponding to the requester's profile\n   * @example\n   *\n   * r.getMe().then(console.log);\n   * // => RedditUser { is_employee: false, has_mail: false, name: 'snoowrap_testing', ... }\n   */\n\n\n  getMe() {\n    var _this4 = this;\n\n    return this._get({\n      uri: 'api/v1/me'\n    }).then(function (result) {\n      _this4._ownUserInfo = _this4._newObject('RedditUser', result, true);\n      return _this4._ownUserInfo;\n    });\n  }\n\n  _getMyName() {\n    return _Promise.default.resolve(this._ownUserInfo ? this._ownUserInfo.name : this.getMe().get('name'));\n  }\n  /**\n   * @summary Gets a distribution of the requester's own karma distribution by subreddit.\n   * @returns {Promise} A Promise for an object with karma information\n   * @example\n   *\n   * r.getKarma().then(console.log)\n   * // => [\n   * //  { sr: Subreddit { display_name: 'redditdev' }, comment_karma: 16, link_karma: 1 },\n   * //  { sr: Subreddit { display_name: 'programming' }, comment_karma: 2, link_karma: 1 },\n   * //  ...\n   * // ]\n   */\n\n\n  getKarma() {\n    return this._get({\n      uri: 'api/v1/me/karma'\n    });\n  }\n  /**\n   * @summary Gets information on the user's current preferences.\n   * @returns {Promise} A promise for an object containing the user's current preferences\n   * @example\n   *\n   * r.getPreferences().then(console.log)\n   * // => { default_theme_sr: null, threaded_messages: true, hide_downs: false, ... }\n   */\n\n\n  getPreferences() {\n    return this._get({\n      uri: 'api/v1/me/prefs'\n    });\n  }\n  /**\n   * @summary Updates the user's current preferences.\n   * @param {object} updatedPreferences An object of the form {[some preference name]: 'some value', ...}. Any preference\n   * not included in this object will simply retain its current value.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.updatePreferences({threaded_messages: false, hide_downs: true})\n   * // => { default_theme_sr: null, threaded_messages: false,hide_downs: true, ... }\n   * // (preferences updated on reddit)\n   */\n\n\n  updatePreferences(updatedPreferences) {\n    return this._patch({\n      uri: 'api/v1/me/prefs',\n      body: updatedPreferences\n    });\n  }\n  /**\n   * @summary Gets the currently-authenticated user's trophies.\n   * @returns {Promise} A TrophyList containing the user's trophies\n   * @example\n   *\n   * r.getMyTrophies().then(console.log)\n   * // => TrophyList { trophies: [\n   * //   Trophy { icon_70: 'https://s3.amazonaws.com/redditstatic/award/verified_email-70.png',\n   * //     description: null,\n   * //     url: null,\n   * //     icon_40: 'https://s3.amazonaws.com/redditstatic/award/verified_email-40.png',\n   * //     award_id: 'o',\n   * //     id: '16fn29',\n   * //     name: 'Verified Email'\n   * //   }\n   * // ] }\n   */\n\n\n  getMyTrophies() {\n    return this._get({\n      uri: 'api/v1/me/trophies'\n    });\n  }\n  /**\n   * @summary Gets the list of the currently-authenticated user's friends.\n   * @returns {Promise} A Promise that resolves with a list of friends\n   * @example\n   *\n   * r.getFriends().then(console.log)\n   * // => [ [ RedditUser { date: 1457927963, name: 'not_an_aardvark', id: 't2_k83md' } ], [] ]\n   */\n\n\n  getFriends() {\n    return this._get({\n      uri: 'prefs/friends'\n    });\n  }\n  /**\n   * @summary Gets the list of people that the currently-authenticated user has blocked.\n   * @returns {Promise} A Promise that resolves with a list of blocked users\n   * @example\n   *\n   * r.getBlockedUsers().then(console.log)\n   * // => [ RedditUser { date: 1457928120, name: 'actually_an_aardvark', id: 't2_q3519' } ]\n   */\n\n\n  getBlockedUsers() {\n    return this._get({\n      uri: 'prefs/blocked'\n    });\n  }\n  /**\n   * @summary Determines whether the currently-authenticated user needs to fill out a captcha in order to submit content.\n   * @returns {Promise} A Promise that resolves with a boolean value\n   * @example\n   *\n   * r.checkCaptchaRequirement().then(console.log)\n   * // => false\n   */\n\n\n  checkCaptchaRequirement() {\n    return this._get({\n      uri: 'api/needs_captcha'\n    });\n  }\n  /**\n   * @summary Gets the identifier (a hex string) for a new captcha image.\n   * @returns {Promise} A Promise that resolves with a string\n   * @example\n   *\n   * r.getNewCaptchaIdentifier().then(console.log)\n   * // => 'o5M18uy4mk0IW4hs0fu2GNPdXb1Dxe9d'\n   */\n\n\n  getNewCaptchaIdentifier() {\n    return this._post({\n      uri: 'api/new_captcha',\n      form: {\n        api_type\n      }\n    }).then(function (res) {\n      return res.json.data.iden;\n    });\n  }\n  /**\n   * @summary Gets an image for a given captcha identifier.\n   * @param {string} identifier The captcha identifier.\n   * @returns {Promise} A string containing raw image data in PNG format\n   * @example\n   *\n   * r.getCaptchaImage('o5M18uy4mk0IW4hs0fu2GNPdXb1Dxe9d').then(console.log)\n   // => (A long, incoherent string representing the image in PNG format)\n   */\n\n\n  getCaptchaImage(identifier) {\n    return this._get({\n      uri: \"captcha/\".concat(identifier)\n    });\n  }\n  /**\n   * @summary Gets an array of categories that items can be saved in. (Requires reddit gold)\n   * @returns {Promise} An array of categories\n   * @example\n   *\n   * r.getSavedCategories().then(console.log)\n   * // => [ { category: 'cute cat pictures' }, { category: 'interesting articles' } ]\n   */\n\n\n  getSavedCategories() {\n    return this._get({\n      uri: 'api/saved_categories'\n    }).get('categories');\n  }\n  /**\n   * @summary Marks a list of submissions as 'visited'.\n   * @desc **Note**: This endpoint only works if the authenticated user is subscribed to reddit gold.\n   * @param {Submission[]} links A list of Submission objects to mark\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * var submissions = [r.getSubmission('4a9u54'), r.getSubmission('4a95nb')]\n   * r.markAsVisited(submissions)\n   * // (the links will now appear purple on reddit)\n   */\n\n\n  markAsVisited(links) {\n    return this._post({\n      uri: 'api/store_visits',\n      links: (0, _lodash.map)(links, 'name').join(',')\n    });\n  }\n\n  _submit(_ref5) {\n    var _this5 = this;\n\n    var captcha_response = _ref5.captcha_response,\n        _ref5$captchaResponse = _ref5.captchaResponse,\n        captchaResponse = _ref5$captchaResponse === void 0 ? captcha_response : _ref5$captchaResponse,\n        captcha_iden = _ref5.captcha_iden,\n        _ref5$captchaIden = _ref5.captchaIden,\n        captchaIden = _ref5$captchaIden === void 0 ? captcha_iden : _ref5$captchaIden,\n        kind = _ref5.kind,\n        _ref5$resubmit = _ref5.resubmit,\n        resubmit = _ref5$resubmit === void 0 ? true : _ref5$resubmit,\n        _ref5$send_replies = _ref5.send_replies,\n        send_replies = _ref5$send_replies === void 0 ? true : _ref5$send_replies,\n        _ref5$sendReplies = _ref5.sendReplies,\n        sendReplies = _ref5$sendReplies === void 0 ? send_replies : _ref5$sendReplies,\n        crosspost_fullname = _ref5.crosspost_fullname,\n        text = _ref5.text,\n        title = _ref5.title,\n        url = _ref5.url,\n        subreddit_name = _ref5.subreddit_name,\n        _ref5$subredditName = _ref5.subredditName,\n        subredditName = _ref5$subredditName === void 0 ? subreddit_name : _ref5$subredditName;\n    return this._post({\n      uri: 'api/submit',\n      form: {\n        api_type,\n        captcha: captchaResponse,\n        iden: captchaIden,\n        sendreplies: sendReplies,\n        sr: subredditName,\n        kind,\n        resubmit,\n        crosspost_fullname,\n        text,\n        title,\n        url\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).then(function (result) {\n      return _this5.getSubmission(result.json.data.id);\n    });\n  }\n  /**\n   * @summary Creates a new selfpost on the given subreddit.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the post should be submitted to\n   * @param {string} options.title The title of the submission\n   * @param {string} [options.text] The selftext of the submission\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * r.submitSelfpost({\n   *   subredditName: 'snoowrap_testing',\n   *   title: 'This is a selfpost',\n   *   text: 'This is the text body of the selfpost'\n   * }).then(console.log)\n   * // => Submission { name: 't3_4abmsz' }\n   * // (new selfpost created on reddit)\n   */\n\n\n  submitSelfpost(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'self'\n    }));\n  }\n  /**\n   * @summary Creates a new link submission on the given subreddit.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the post should be submitted to\n   * @param {string} options.title The title of the submission\n   * @param {string} options.url The url that the link submission should point to\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n   the past, reddit will return an error. This could be used to avoid accidental reposts.\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * r.submitLink({\n   *   subredditName: 'snoowrap_testing',\n   *   title: 'I found a cool website!',\n   *   url: 'https://google.com'\n   * }).then(console.log)\n   * // => Submission { name: 't3_4abnfe' }\n   * // (new linkpost created on reddit)\n   */\n\n\n  submitLink(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'link'\n    }));\n  }\n  /**\n   * @summary Creates a new crosspost submission on the given subreddit\n   * @desc **NOTE**: To create a crosspost, the authenticated account must be subscribed to the subreddit where\n   * the crosspost is being submitted, and that subreddit be configured to allow crossposts.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the crosspost should be submitted to\n   * @param {string} options.title The title of the crosspost\n   * @param {(string|Submission)} options.originalPost A Submission object or a post ID for the original post which\n   is being crossposted\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n   the past, reddit will return an error. This could be used to avoid accidental reposts.\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * await r.submitCrosspost({ title: 'I found an interesting post', originalPost: '6vths0', subredditName: 'snoowrap' })\n   */\n\n\n  submitCrosspost(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'crosspost',\n      crosspost_fullname: options.originalPost instanceof snoowrap.objects.Submission ? options.originalPost.name : (0, _helpers.addFullnamePrefix)(options.originalPost, 't3_')\n    }));\n  }\n\n  _getSortedFrontpage(sortType, subredditName) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Handle things properly if only a time parameter is provided but not the subreddit name\n\n    var opts = options;\n    var subName = subredditName;\n\n    if (typeof subredditName === 'object' && (0, _lodash.isEmpty)((0, _lodash.omitBy)(opts, function (option) {\n      return option === undefined;\n    }))) {\n      /* In this case, \"subredditName\" ends up referring to the second argument, which is not actually a name since the user\n      decided to omit that parameter. */\n      opts = subredditName;\n      subName = undefined;\n    }\n\n    var parsedOptions = (0, _lodash.omit)(_objectSpread({}, opts, {\n      t: opts.time || opts.t\n    }), 'time');\n    return this._getListing({\n      uri: (subName ? \"r/\".concat(subName, \"/\") : '') + sortType,\n      qs: parsedOptions\n    });\n  }\n  /**\n   * @summary Gets a Listing of hot posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getHot().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'pics' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getHot('gifs').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'gifs' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'gifs' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getHot('redditdev', {limit: 1}).then(console.log)\n   * // => Listing [\n   //   Submission { domain: 'self.redditdev', banned_by: null, subreddit: Subreddit { display_name: 'redditdev' }, ...}\n   * // ]\n   */\n\n\n  getHot(subredditName, options) {\n    return this._getSortedFrontpage('hot', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of best posts.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise<Listing>} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getBest().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'pics' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getBest({limit: 1}).then(console.log)\n   * // => Listing [\n   //   Submission { domain: 'self.redditdev', banned_by: null, subreddit: Subreddit { display_name: 'redditdev' }, ...}\n   * // ]\n   */\n\n\n  getBest(options) {\n    return this._getSortedFrontpage('best', undefined, options);\n  }\n  /**\n   * @summary Gets a Listing of new posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getNew().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.Jokes', banned_by: null, subreddit: Subreddit { display_name: 'Jokes' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  ...\n   * // ]\n   *\n   */\n\n\n  getNew(subredditName, options) {\n    return this._getSortedFrontpage('new', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of new comments.\n   * @param {string} [subredditName] The subreddit to get comments from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved comments\n   * @example\n   *\n   * r.getNewComments().then(console.log)\n   * // => Listing [\n   * //  Comment { link_title: 'What amazing book should be made into a movie, but hasn\\'t been yet?', ... }\n   * //  Comment { link_title: 'How far back in time could you go and still understand English?', ... }\n   * // ]\n   */\n\n\n  getNewComments(subredditName, options) {\n    return this._getSortedFrontpage('comments', subredditName, options);\n  }\n  /**\n   *  @summary Get list of content by IDs. Returns a listing of the requested content.\n   *  @param {Array<string|Submission|Comment>} ids An array of content IDs. Can include the id itself, or a Submission or Comment object.\n  can get a post and a comment   *  @returns {Promise<Listing<Submission|Comment>>} A listing of content requested, can be any class fetchable by API. e.g. Comment, Submission\n   *  @example\n   *\n   * r.getContentByIds(['t3_9l9vof','t3_9la341']).then(console.log);\n   * // => Listing [\n   * //  Submission { approved_at_utc: null, ... }\n   * //  Submission { approved_at_utc: null, ... }\n   * // ]\n   *\n   * r.getContentByIds([r.getSubmission('9l9vof'), r.getSubmission('9la341')]).then(console.log);\n   * // => Listing [\n   * //  Submission { approved_at_utc: null, ... }\n   * //  Submission { approved_at_utc: null, ... }\n   * // ]\n  */\n\n\n  getContentByIds(ids) {\n    if (!Array.isArray(ids)) {\n      throw new TypeError('Invalid argument: Argument needs to be an array.');\n    }\n\n    var prefixedIds = ids.map(function (id) {\n      if (id instanceof snoowrap.objects.Submission || id instanceof snoowrap.objects.Comment) {\n        return id.name;\n      } else if (typeof id === 'string') {\n        if (!/t(1|3)_/g.test(ids)) {\n          throw new TypeError('Invalid argument: Ids need to include Submission or Comment prefix, e.g. t1_, t3_.');\n        }\n\n        return id;\n      }\n\n      throw new TypeError('Id must be either a string, Submission, or Comment.');\n    });\n    return this._get({\n      uri: '/api/info',\n      method: 'get',\n      qs: {\n        id: prefixedIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Gets a single random Submission.\n   * @desc **Note**: This function will not work when snoowrap is running in a browser, because the reddit server sends a\n   redirect which cannot be followed by a CORS request.\n   * @param {string} [subredditName] The subreddit to get the random submission. If not provided, the post is fetched from\n   the front page of reddit.\n   * @returns {Promise} The retrieved Submission object\n   * @example\n   *\n   * r.getRandomSubmission('aww').then(console.log)\n   * // => Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'aww' }, ... }\n   */\n\n\n  getRandomSubmission(subredditName) {\n    return this._get({\n      uri: \"\".concat(subredditName ? \"r/\".concat(subredditName, \"/\") : '', \"random\")\n    });\n  }\n  /**\n   * @summary Gets a Listing of top posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n   `hour, day, week, month, year, all`\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getTop({time: 'all', limit: 2}).then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... }\n   * // ]\n   *\n   * r.getTop('AskReddit').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  ...\n   * // ]\n   */\n\n\n  getTop(subredditName, options) {\n    return this._getSortedFrontpage('top', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of controversial posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n   `hour, day, week, month, year, all`\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getControversial('technology').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'thenextweb.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... },\n   * //  Submission { domain: 'pcmag.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... }\n   * // ]\n   */\n\n\n  getControversial(subredditName, options) {\n    return this._getSortedFrontpage('controversial', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of controversial posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getRising('technology').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'thenextweb.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... },\n   * //  Submission { domain: 'pcmag.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... }\n   * // ]\n   */\n\n\n  getRising(subredditName, options) {\n    return this._getSortedFrontpage('rising', subredditName, options);\n  }\n  /**\n   * @summary Gets the authenticated user's unread messages.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing unread items in the user's inbox\n   * @example\n   *\n   * r.getUnreadMessages().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'hi!', was_comment: false, first_message: null, ... },\n   * //  Comment { body: 'this is a reply', link_title: 'Yay, a selfpost!', was_comment: true, ... }\n   * // ]\n   */\n\n\n  getUnreadMessages() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/unread',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets the items in the authenticated user's inbox.\n   * @param {object} [options={}] Filter options. Can also contain options for the resulting Listing.\n   * @param {string} [options.filter] A filter for the inbox items. If provided, it should be one of `unread`, (unread\n   items), `messages` (i.e. PMs), `comments` (comment replies), `selfreply` (selfpost replies), or `mentions` (username\n   mentions).\n   * @returns {Promise} A Listing containing items in the user's inbox\n   * @example\n   *\n   * r.getInbox().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'hi!', was_comment: false, first_message: null, ... },\n   * //  Comment { body: 'this is a reply', link_title: 'Yay, a selfpost!', was_comment: true, ... }\n   * // ]\n   */\n\n\n  getInbox() {\n    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        filter = _ref6.filter,\n        options = _objectWithoutProperties(_ref6, [\"filter\"]);\n\n    return this._getListing({\n      uri: \"message/\".concat(filter || 'inbox'),\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets the authenticated user's modmail.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing of the user's modmail\n   * @example\n   *\n   * r.getModmail({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: '/u/not_an_aardvark has accepted an invitation to become moderator ... ', ... },\n   * //  PrivateMessage { body: '/u/not_an_aardvark has been invited by /u/actually_an_aardvark to ...', ... }\n   * // ]\n   */\n\n\n  getModmail() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/moderator',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of ModmailConversations from the authenticated user's subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise<Listing<ModmailConversation>>} A Listing containing Subreddits\n   * @example\n   *\n   * r.getNewModmailConversations({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... },\n   * //  ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... }\n   * // ]\n   */\n\n\n  getNewModmailConversations() {\n    var _this6 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'api/mod/conversations',\n      qs: options,\n      _name: 'ModmailConversation',\n      _transform: function (response) {\n        response.after = null;\n        response.before = null;\n        response.children = [];\n\n        for (var conversation of response.conversationIds) {\n          response.conversations[conversation].participant = _this6._newObject('ModmailConversationAuthor', _objectSpread({}, response.conversations[conversation].participant));\n\n          var conversationObjects = objects.ModmailConversation._getConversationObjects(response.conversations[conversation], response);\n\n          var data = _objectSpread({}, conversationObjects, {}, response.conversations[conversation]);\n\n          response.children.push(_this6._newObject('ModmailConversation', data));\n        }\n\n        return _this6._newObject('Listing', response);\n      }\n    });\n  }\n  /**\n   * @summary Create a new modmail discussion between moderators\n   * @param {object} options\n   * @param {string} options.body Body of the discussion\n   * @param {string} options.subject Title or subject\n   * @param {string} options.srName Subreddit name without fullname\n   * @returns {Promise<ModmailConversation>} the created ModmailConversation\n   * @example\n   *\n   * r.createModeratorDiscussion({\n   *   body: 'test body',\n   *   subject: 'test subject',\n   *   srName: 'AskReddit'\n   * }).then(console.log)\n   * // ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... }\n   */\n\n\n  createModmailDiscussion(_ref7) {\n    var _this7 = this;\n\n    var body = _ref7.body,\n        subject = _ref7.subject,\n        srName = _ref7.srName;\n    var parsedFromSr = srName.replace(/^\\/?r\\//, ''); // Convert '/r/subreddit_name' to 'subreddit_name'\n    // _newObject ignores most of the response, no practical way to parse the returned content yet\n\n    return this._post({\n      uri: 'api/mod/conversations',\n      form: {\n        body,\n        subject,\n        srName: parsedFromSr\n      }\n    }).then(function (res) {\n      return _this7._newObject('ModmailConversation', {\n        id: res.conversation.id\n      });\n    });\n  }\n  /**\n   * @summary Get a ModmailConversation by its id\n   * @param {string} id of the ModmailConversation\n   * @returns {Promise<ModmailConversation>} the requested ModmailConversation\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').then(console.log)\n   * // ModmailConversation { messages: [...], objIds: [...], ... }\n   */\n\n\n  getNewModmailConversation(id) {\n    return this._newObject('ModmailConversation', {\n      id\n    });\n  }\n  /**\n   * @summary Marks all conversations in array as read.\n   * @param {ModmailConversation[]} conversations to mark as read\n   * @example\n   *\n   * r.markNewModmailConversationsAsRead(['pics', 'sweden'])\n   */\n\n\n  markNewModmailConversationsAsRead(conversations) {\n    var conversationIds = conversations.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, '');\n    });\n    return this._post({\n      uri: 'api/mod/conversations/read',\n      form: {\n        conversationIds: conversationIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all conversations in array as unread.\n   * @param {ModmailConversation[]} conversations to mark as unread\n   * @example\n   *\n   * r.markNewModmailConversationsAsUnread(['pics', 'sweden'])\n   */\n\n\n  markNewModmailConversationsAsUnread(conversations) {\n    var conversationIds = conversations.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, '');\n    });\n    return this._post({\n      uri: 'api/mod/conversations/unread',\n      form: {\n        conversationIds: conversationIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Gets all moderated subreddits that have new Modmail activated\n   * @returns {Promise<Listing<Subreddit>>} a Listing of ModmailConversations marked as read\n   * @example\n   *\n   * r.getNewModmailSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit { display_name: 'tipofmytongue', ... },\n   * //  Subreddit { display_name: 'EarthPorn', ... },\n   * // ]\n   */\n\n\n  getNewModmailSubreddits() {\n    var _this8 = this;\n\n    return this._get({\n      uri: 'api/mod/conversations/subreddits'\n    }).then(function (response) {\n      return Object.values(response.subreddits).map(function (s) {\n        return _this8._newObject('Subreddit', s);\n      });\n    });\n  }\n  /**\n   * @summary Represents the unread count in a {@link ModmailConversation}. Each of these properties\n   * correspond to the amount of unread conversations of that type.\n   * @typedef {Object} UnreadCount\n   * @property {number} highlighted\n   * @property {number} notifications\n   * @property {number} archived\n   * @property {number} new\n   * @property {number} inprogress\n   * @property {number} mod\n   */\n\n  /**\n   * @summary Retrieves an object of unread Modmail conversations for each state.\n   * @returns {UnreadCount} unreadCount\n   * @example\n   *\n   * r.getUnreadNewModmailConversationsCount().then(console.log)\n   * // => {\n   * //  highlighted: 1,\n   * //  notifications: 0,\n   * //  archived: 0,\n   * //  new: 2,\n   * //  inprogress: 5,\n   * //  mod: 1,\n   * // }\n   */\n\n\n  getUnreadNewModmailConversationsCount() {\n    return this._get({\n      uri: 'api/mod/conversations/unread/count'\n    });\n  }\n  /**\n   * @summary Mark Modmail conversations as read given the subreddit(s) and state.\n   * @param {Subreddit[]|String[]} subreddits\n   * @param {('new'|'inprogress'|'mod'|'notifications'|'archived'|'highlighted'|'all')} state selected state to mark as read\n   * @returns {Promise<Listing<ModmailConversation>>} a Listing of ModmailConversations marked as read\n   * @example\n   *\n   * r.bulkReadNewModmail(['AskReddit'], 'all').then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { id: '75hxt' },\n   * //  ModmailConversation { id: '75hxg' }\n   * // ]\n   *\n   * r.bulkReadNewModmail([r.getSubreddit('AskReddit')], 'all').then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { id: '75hxt' },\n   * //  ModmailConversation { id: '75hxg' }\n   * // ]\n   */\n\n\n  bulkReadNewModmail(subreddits, state) {\n    var _this9 = this;\n\n    var subredditNames = subreddits.map(function (s) {\n      return typeof s === 'string' ? s.replace(/^\\/?r\\//, '') : s.display_name;\n    });\n    return this._post({\n      uri: 'api/mod/conversations/bulk/read',\n      form: {\n        entity: subredditNames.join(','),\n        state\n      }\n    }).then(function (res) {\n      return _this9._newObject('Listing', {\n        after: null,\n        before: null,\n        children: res.conversation_ids.map(function (id) {\n          return _this9._newObject('ModmailConversation', {\n            id\n          });\n        })\n      });\n    });\n  }\n  /**\n   * @summary Gets the user's sent messages.\n   * @param {object} [options={}] options for the resulting Listing\n   * @returns {Promise} A Listing of the user's sent messages\n   * @example\n   *\n   * r.getSentMessages().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'you have been added as an approved submitter to ...', ... },\n   * //  PrivateMessage { body: 'you have been banned from posting to ...' ... }\n   * // ]\n   */\n\n\n  getSentMessages() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/sent',\n      qs: options\n    });\n  }\n  /**\n   * @summary Marks all of the given messages as read.\n   * @param {PrivateMessage[]|String[]} messages An Array of PrivateMessage or Comment objects. Can also contain strings\n   representing message or comment IDs. If strings are provided, they are assumed to represent PrivateMessages unless a fullname\n   prefix such as `t1_` is specified.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.markMessagesAsRead(['51shsd', '51shxv'])\n   *\n   * // To reference a comment by ID, be sure to use the `t1_` prefix, otherwise snoowrap will be unable to distinguish the\n   * // comment ID from a PrivateMessage ID.\n   * r.markMessagesAsRead(['t5_51shsd', 't1_d3zhb5k'])\n   *\n   * // Alternatively, just pass in a comment object directly.\n   * r.markMessagesAsRead([r.getMessage('51shsd'), r.getComment('d3zhb5k')])\n   */\n\n\n  markMessagesAsRead(messages) {\n    var messageIds = messages.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, 't4_');\n    });\n    return this._post({\n      uri: 'api/read_message',\n      form: {\n        id: messageIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all of the given messages as unread.\n   * @param {PrivateMessage[]|String[]} messages An Array of PrivateMessage or Comment objects. Can also contain strings\n   representing message IDs. If strings are provided, they are assumed to represent PrivateMessages unless a fullname prefix such\n   as `t1_` is included.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.markMessagesAsUnread(['51shsd', '51shxv'])\n   *\n   * // To reference a comment by ID, be sure to use the `t1_` prefix, otherwise snoowrap will be unable to distinguish the\n   * // comment ID from a PrivateMessage ID.\n   * r.markMessagesAsUnread(['t5_51shsd', 't1_d3zhb5k'])\n   *\n   * // Alternatively, just pass in a comment object directly.\n   * r.markMessagesAsRead([r.getMessage('51shsd'), r.getComment('d3zhb5k')])\n   */\n\n\n  markMessagesAsUnread(messages) {\n    var messageIds = messages.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, 't4_');\n    });\n    return this._post({\n      uri: 'api/unread_message',\n      form: {\n        id: messageIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all of the user's messages as read.\n   * @desc **Note:** The reddit.com site imposes a ratelimit of approximately 1 request every 10 minutes on this endpoint.\n   Further requests will cause the API to return a 429 error.\n   * @returns {Promise} A Promise that resolves when the request is complete\n   * @example\n   *\n   * r.readAllMessages().then(function () {\n   *   r.getUnreadMessages().then(console.log)\n   * })\n   * // => Listing []\n   * // (messages marked as 'read' on reddit)\n   */\n\n\n  readAllMessages() {\n    return this._post({\n      uri: 'api/read_all_messages'\n    });\n  }\n  /**\n   * @summary Composes a new private message.\n   * @param {object} options\n   * @param {RedditUser|Subreddit|string} options.to The recipient of the message.\n   * @param {string} options.subject The message subject (100 characters max)\n   * @param {string} options.text The body of the message, in raw markdown text\n   * @param {Subreddit|string} [options.fromSubreddit] If provided, the message is sent as a modmail from the specified\n   subreddit.\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.composeMessage({\n   *   to: 'actually_an_aardvark',\n   *   subject: \"Hi, how's it going?\",\n   *   text: 'Long time no see'\n   * })\n   * // (message created on reddit)\n   */\n\n\n  composeMessage(_ref8) {\n    var captcha = _ref8.captcha,\n        from_subreddit = _ref8.from_subreddit,\n        _ref8$fromSubreddit = _ref8.fromSubreddit,\n        fromSubreddit = _ref8$fromSubreddit === void 0 ? from_subreddit : _ref8$fromSubreddit,\n        captcha_iden = _ref8.captcha_iden,\n        _ref8$captchaIden = _ref8.captchaIden,\n        captchaIden = _ref8$captchaIden === void 0 ? captcha_iden : _ref8$captchaIden,\n        subject = _ref8.subject,\n        text = _ref8.text,\n        to = _ref8.to;\n    var parsedTo = to;\n    var parsedFromSr = fromSubreddit;\n\n    if (to instanceof snoowrap.objects.RedditUser) {\n      parsedTo = to.name;\n    } else if (to instanceof snoowrap.objects.Subreddit) {\n      parsedTo = \"/r/\".concat(to.display_name);\n    }\n\n    if (fromSubreddit instanceof snoowrap.objects.Subreddit) {\n      parsedFromSr = fromSubreddit.display_name;\n    } else if (typeof fromSubreddit === 'string') {\n      parsedFromSr = fromSubreddit.replace(/^\\/?r\\//, ''); // Convert '/r/subreddit_name' to 'subreddit_name'\n    }\n\n    return this._post({\n      uri: 'api/compose',\n      form: {\n        api_type,\n        captcha,\n        iden: captchaIden,\n        from_sr: parsedFromSr,\n        subject,\n        text,\n        to: parsedTo\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).return({});\n  }\n  /**\n   * @summary Gets a list of all oauth scopes supported by the reddit API.\n   * @desc **Note**: This lists every single oauth scope. To get the scope of this requester, use the `scope` property instead.\n   * @returns {Promise} An object containing oauth scopes.\n   * @example\n   *\n   * r.getOauthScopeList().then(console.log)\n   * // => {\n   * //  creddits: {\n   * //    description: 'Spend my reddit gold creddits on giving gold to other users.',\n   * //    id: 'creddits',\n   * //    name: 'Spend reddit gold creddits'\n   * //  },\n   * //  modcontributors: {\n   * //    description: 'Add/remove users to approved submitter lists and ban/unban or mute/unmute users from ...',\n   * //    id: 'modcontributors',\n   * //    name: 'Approve submitters and ban users'\n   * //  },\n   * //  ...\n   * // }\n   */\n\n\n  getOauthScopeList() {\n    return this._get({\n      uri: 'api/v1/scopes'\n    });\n  }\n  /**\n   * @summary Conducts a search of reddit submissions.\n   * @param {object} options Search options. Can also contain options for the resulting Listing.\n   * @param {string} options.query The search query\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. One of\n   `hour, day, week, month, year, all`\n   * @param {Subreddit|string} [options.subreddit] The subreddit to conduct the search on.\n   * @param {boolean} [options.restrictSr=true] Restricts search results to the given subreddit\n   * @param {string} [options.sort] Determines how the results should be sorted. One of `relevance, hot, top, new, comments`\n   * @param {string} [options.syntax='plain'] Specifies a syntax for the search. One of `cloudsearch, lucene, plain`\n   * @returns {Promise} A Listing containing the search results.\n   * @example\n   *\n   * r.search({\n   *   query: 'Cute kittens',\n   *   subreddit: 'aww',\n   *   sort: 'top'\n   * }).then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, ... },\n   * //  Submission { domain: 'imgur.com', banned_by: null, ... },\n   * //  ...\n   * // ]\n   */\n\n\n  search(options) {\n    if (options.subreddit instanceof snoowrap.objects.Subreddit) {\n      options.subreddit = options.subreddit.display_name;\n    }\n\n    (0, _lodash.defaults)(options, {\n      restrictSr: true,\n      syntax: 'plain'\n    });\n    var parsedQuery = (0, _lodash.omit)(_objectSpread({}, options, {\n      t: options.time,\n      q: options.query,\n      restrict_sr: options.restrictSr\n    }), ['time', 'query']);\n    return this._getListing({\n      uri: \"\".concat(options.subreddit ? \"r/\".concat(options.subreddit, \"/\") : '', \"search\"),\n      qs: parsedQuery\n    });\n  }\n  /**\n   * @summary Searches for subreddits given a query.\n   * @param {object} options\n   * @param {string} options.query A search query (50 characters max)\n   * @param {boolean} [options.exact=false] Determines whether the results shouldbe limited to exact matches.\n   * @param {boolean} [options.includeNsfw=true] Determines whether the results should include NSFW subreddits.\n   * @returns {Promise} An Array containing subreddit names\n   * @example\n   *\n   * r.searchSubredditNames({query: 'programming'}).then(console.log)\n   * // => [\n   * //  'programming',\n   * //  'programmingcirclejerk',\n   * //  'programminghorror',\n   * //  ...\n   * // ]\n   */\n\n\n  searchSubredditNames(_ref9) {\n    var _ref9$exact = _ref9.exact,\n        exact = _ref9$exact === void 0 ? false : _ref9$exact,\n        _ref9$include_nsfw = _ref9.include_nsfw,\n        include_nsfw = _ref9$include_nsfw === void 0 ? true : _ref9$include_nsfw,\n        _ref9$includeNsfw = _ref9.includeNsfw,\n        includeNsfw = _ref9$includeNsfw === void 0 ? include_nsfw : _ref9$includeNsfw,\n        query = _ref9.query;\n    return this._post({\n      uri: 'api/search_reddit_names',\n      qs: {\n        exact,\n        include_over_18: includeNsfw,\n        query\n      }\n    }).get('names');\n  }\n\n  _createOrEditSubreddit(_ref10) {\n    var _ref10$allow_images = _ref10.allow_images,\n        allow_images = _ref10$allow_images === void 0 ? true : _ref10$allow_images,\n        _ref10$allow_top = _ref10.allow_top,\n        allow_top = _ref10$allow_top === void 0 ? true : _ref10$allow_top,\n        captcha = _ref10.captcha,\n        captcha_iden = _ref10.captcha_iden,\n        _ref10$collapse_delet = _ref10.collapse_deleted_comments,\n        collapse_deleted_comments = _ref10$collapse_delet === void 0 ? false : _ref10$collapse_delet,\n        _ref10$comment_score_ = _ref10.comment_score_hide_mins,\n        comment_score_hide_mins = _ref10$comment_score_ === void 0 ? 0 : _ref10$comment_score_,\n        description = _ref10.description,\n        _ref10$exclude_banned = _ref10.exclude_banned_modqueue,\n        exclude_banned_modqueue = _ref10$exclude_banned === void 0 ? false : _ref10$exclude_banned,\n        header_title = _ref10['header-title'],\n        _ref10$hide_ads = _ref10.hide_ads,\n        hide_ads = _ref10$hide_ads === void 0 ? false : _ref10$hide_ads,\n        _ref10$lang = _ref10.lang,\n        lang = _ref10$lang === void 0 ? 'en' : _ref10$lang,\n        _ref10$link_type = _ref10.link_type,\n        link_type = _ref10$link_type === void 0 ? 'any' : _ref10$link_type,\n        name = _ref10.name,\n        _ref10$over_ = _ref10.over_18,\n        over_18 = _ref10$over_ === void 0 ? false : _ref10$over_,\n        public_description = _ref10.public_description,\n        _ref10$public_traffic = _ref10.public_traffic,\n        public_traffic = _ref10$public_traffic === void 0 ? false : _ref10$public_traffic,\n        _ref10$show_media = _ref10.show_media,\n        show_media = _ref10$show_media === void 0 ? false : _ref10$show_media,\n        _ref10$show_media_pre = _ref10.show_media_preview,\n        show_media_preview = _ref10$show_media_pre === void 0 ? true : _ref10$show_media_pre,\n        _ref10$spam_comments = _ref10.spam_comments,\n        spam_comments = _ref10$spam_comments === void 0 ? 'high' : _ref10$spam_comments,\n        _ref10$spam_links = _ref10.spam_links,\n        spam_links = _ref10$spam_links === void 0 ? 'high' : _ref10$spam_links,\n        _ref10$spam_selfposts = _ref10.spam_selfposts,\n        spam_selfposts = _ref10$spam_selfposts === void 0 ? 'high' : _ref10$spam_selfposts,\n        _ref10$spoilers_enabl = _ref10.spoilers_enabled,\n        spoilers_enabled = _ref10$spoilers_enabl === void 0 ? false : _ref10$spoilers_enabl,\n        sr = _ref10.sr,\n        _ref10$submit_link_la = _ref10.submit_link_label,\n        submit_link_label = _ref10$submit_link_la === void 0 ? '' : _ref10$submit_link_la,\n        _ref10$submit_text_la = _ref10.submit_text_label,\n        submit_text_label = _ref10$submit_text_la === void 0 ? '' : _ref10$submit_text_la,\n        _ref10$submit_text = _ref10.submit_text,\n        submit_text = _ref10$submit_text === void 0 ? '' : _ref10$submit_text,\n        _ref10$suggested_comm = _ref10.suggested_comment_sort,\n        suggested_comment_sort = _ref10$suggested_comm === void 0 ? 'confidence' : _ref10$suggested_comm,\n        title = _ref10.title,\n        _ref10$type = _ref10.type,\n        type = _ref10$type === void 0 ? 'public' : _ref10$type,\n        wiki_edit_age = _ref10.wiki_edit_age,\n        wiki_edit_karma = _ref10.wiki_edit_karma,\n        _ref10$wikimode = _ref10.wikimode,\n        wikimode = _ref10$wikimode === void 0 ? 'modonly' : _ref10$wikimode;\n    return this._post({\n      uri: 'api/site_admin',\n      form: {\n        allow_images,\n        allow_top,\n        api_type,\n        captcha,\n        collapse_deleted_comments,\n        comment_score_hide_mins,\n        description,\n        exclude_banned_modqueue,\n        'header-title': header_title,\n        hide_ads,\n        iden: captcha_iden,\n        lang,\n        link_type,\n        name,\n        over_18,\n        public_description,\n        public_traffic,\n        show_media,\n        show_media_preview,\n        spam_comments,\n        spam_links,\n        spam_selfposts,\n        spoilers_enabled,\n        sr,\n        submit_link_label,\n        submit_text,\n        submit_text_label,\n        suggested_comment_sort,\n        title,\n        type,\n        wiki_edit_age,\n        wiki_edit_karma,\n        wikimode\n      }\n    }).then((0, _helpers.handleJsonErrors)(this.getSubreddit(name || sr)));\n  }\n  /**\n   * @summary Creates a new subreddit.\n   * @param {object} options\n   * @param {string} options.name The name of the new subreddit\n   * @param {string} options.title The text that should appear in the header of the subreddit\n   * @param {string} options.public_description The text that appears with this subreddit on the search page, or on the\n   blocked-access page if this subreddit is private. (500 characters max)\n   * @param {string} options.description The sidebar text for the subreddit. (5120 characters max)\n   * @param {string} [options.submit_text=''] The text to show below the submission page (1024 characters max)\n   * @param {boolean} [options.hide_ads=false] Determines whether ads should be hidden on this subreddit. (This is only\n   allowed for gold-only subreddits.)\n   * @param {string} [options.lang='en'] The language of the subreddit (represented as an IETF language tag)\n   * @param {string} [options.type='public'] Determines who should be able to access the subreddit. This should be one of\n   `public, private, restricted, gold_restricted, gold_only, archived, employees_only`.\n   * @param {string} [options.link_type='any'] Determines what types of submissions are allowed on the subreddit. This should\n   be one of `any, link, self`.\n   * @param {string} [options.submit_link_label=undefined] Custom text to display on the button that submits a link. If\n   this is omitted, the default text will be displayed.\n   * @param {string} [options.submit_text_label=undefined] Custom text to display on the button that submits a selfpost. If\n   this is omitted, the default text will be displayed.\n   * @param {string} [options.wikimode='modonly'] Determines who can edit wiki pages on the subreddit. This should be one of\n   `modonly, anyone, disabled`.\n   * @param {number} [options.wiki_edit_karma=0] The minimum amount of subreddit karma needed for someone to edit this\n   subreddit's wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n   * @param {number} [options.wiki_edit_age=0] The minimum account age (in days) needed for someone to edit this subreddit's\n   wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n   * @param {string} [options.spam_links='high'] The spam filter strength for links on this subreddit. This should be one of\n   `low, high, all`.\n   * @param {string} [options.spam_selfposts='high'] The spam filter strength for selfposts on this subreddit. This should be\n   one of `low, high, all`.\n   * @param {string} [options.spam_comments='high'] The spam filter strength for comments on this subreddit. This should be one\n   of `low, high, all`.\n   * @param {boolean} [options.over_18=false] Determines whether this subreddit should be classified as NSFW\n   * @param {boolean} [options.allow_top=true] Determines whether the new subreddit should be able to appear in /r/all and\n   trending subreddits\n   * @param {boolean} [options.show_media=false] Determines whether image thumbnails should be enabled on this subreddit\n   * @param {boolean} [options.show_media_preview=true] Determines whether media previews should be expanded by default on this\n   subreddit\n   * @param {boolean} [options.allow_images=true] Determines whether image uploads and links to image hosting sites should be\n   enabled on this subreddit\n   * @param {boolean} [options.exclude_banned_modqueue=false] Determines whether posts by site-wide banned users should be\n   excluded from the modqueue.\n   * @param {boolean} [options.public_traffic=false] Determines whether the /about/traffic page for this subreddit should be\n   viewable by anyone.\n   * @param {boolean} [options.collapse_deleted_comments=false] Determines whether deleted and removed comments should be\n   collapsed by default\n   * @param {string} [options.suggested_comment_sort=undefined] The suggested comment sort for the subreddit. This should be\n   one of `confidence, top, new, controversial, old, random, qa`.If left blank, there will be no suggested sort,\n   which means that users will see the sort method that is set in their own preferences (usually `confidence`.)\n   * @param {boolean} [options.spoilers_enabled=false] Determines whether users can mark their posts as spoilers\n   * @returns {Promise} A Promise for the newly-created subreddit object.\n   * @example\n   *\n   * r.createSubreddit({\n   *   name: 'snoowrap_testing2',\n   *   title: 'snoowrap testing: the sequel',\n   *   public_description: 'thanks for reading the snoowrap docs!',\n   *   description: 'This text will go on the sidebar',\n   *   type: 'private'\n   * }).then(console.log)\n   * // => Subreddit { display_name: 'snoowrap_testing2' }\n   * // (/r/snoowrap_testing2 created on reddit)\n   */\n\n\n  createSubreddit(options) {\n    return this._createOrEditSubreddit(options);\n  }\n  /**\n   * @summary Searches subreddits by topic.\n   * @param {object} options\n   * @param {string} options.query The search query. (50 characters max)\n   * @returns {Promise} An Array of subreddit objects corresponding to the search results\n   * @deprecated Reddit no longer provides the corresponding API endpoint.\n   * @example\n   *\n   * r.searchSubredditTopics({query: 'movies'}).then(console.log)\n   * // => [\n   * //  Subreddit { display_name: 'tipofmytongue' },\n   * //  Subreddit { display_name: 'remove' },\n   * //  Subreddit { display_name: 'horror' },\n   * //  ...\n   * // ]\n   */\n\n\n  searchSubredditTopics(_ref11) {\n    var _this10 = this;\n\n    var query = _ref11.query;\n    return this._get({\n      uri: 'api/subreddits_by_topic',\n      qs: {\n        query\n      }\n    }).map(function (result) {\n      return _this10.getSubreddit(result.name);\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits that the currently-authenticated user is subscribed to.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getSubscriptions({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'gadgets',\n   * //    title: 'reddit gadget guide',\n   * //    ...\n   * //  },\n   * //  Subreddit {\n   * //    display_name: 'sports',\n   * //    title: 'the sportspage of the Internet',\n   * //    ...\n   * //  }\n   * // ]\n   */\n\n\n  getSubscriptions(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/subscriber',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits in which the currently-authenticated user is an approved submitter.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getContributorSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'snoowrap_testing',\n   * //    title: 'snoowrap',\n   * //    ...\n   * //  }\n   * // ]\n   *\n   */\n\n\n  getContributorSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/contributor',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits in which the currently-authenticated user is a moderator.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getModeratedSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'snoowrap_testing',\n   * //    title: 'snoowrap',\n   * //    ...\n   * //  }\n   * // ]\n   */\n\n\n  getModeratedSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/moderator',\n      qs: options\n    });\n  }\n  /**\n   * @summary Searches subreddits by title and description.\n   * @param {object} options Options for the search. May also contain Listing parameters.\n   * @param {string} options.query The search query\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.searchSubreddits({query: 'cookies'}).then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  searchSubreddits(options) {\n    options.q = options.query;\n    return this._getListing({\n      uri: 'subreddits/search',\n      qs: (0, _lodash.omit)(options, 'query')\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits, arranged by popularity.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getPopularSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getPopularSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/popular',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits, arranged by age.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getNewSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getNewSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/new',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of gold-exclusive subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getGoldSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getGoldSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/gold',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of default subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getDefaultSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getDefaultSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/default',\n      qs: options\n    });\n  }\n  /**\n   * @summary Checks whether a given username is available for registration\n   * @desc **Note:** This function will not work when snoowrap is running in a browser, due to an issue with reddit's CORS\n   settings.\n   * @param {string} name The username in question\n   * @returns {Promise} A Promise that fulfills with a Boolean (`true` or `false`)\n   * @example\n   *\n   * r.checkUsernameAvailability('not_an_aardvark').then(console.log)\n   * // => false\n   * r.checkUsernameAvailability('eqwZAr9qunx7IHqzWVeF').then(console.log)\n   * // => true\n   */\n\n\n  checkUsernameAvailability(name) {\n    // The oauth endpoint listed in reddit's documentation doesn't actually work, so just send an unauthenticated request.\n    return this.unauthenticatedRequest({\n      uri: 'api/username_available.json',\n      qs: {\n        user: name\n      }\n    });\n  }\n  /**\n   * @summary Creates a new LiveThread.\n   * @param {object} options\n   * @param {string} options.title The title of the livethread (100 characters max)\n   * @param {string} [options.description] A descriptions of the thread. 120 characters max\n   * @param {string} [options.resources] Information and useful links related to the thread. 120 characters max\n   * @param {boolean} [options.nsfw=false] Determines whether the thread is Not Safe For Work\n   * @returns {Promise} A Promise that fulfills with the new LiveThread when the request is complete\n   * @example\n   *\n   * r.createLivethread({title: 'My livethread'}).then(console.log)\n   * // => LiveThread { id: 'wpimncm1f01j' }\n   */\n\n\n  createLivethread(_ref12) {\n    var _this11 = this;\n\n    var title = _ref12.title,\n        description = _ref12.description,\n        resources = _ref12.resources,\n        _ref12$nsfw = _ref12.nsfw,\n        nsfw = _ref12$nsfw === void 0 ? false : _ref12$nsfw;\n    return this._post({\n      uri: 'api/live/create',\n      form: {\n        api_type,\n        description,\n        nsfw,\n        resources,\n        title\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).then(function (result) {\n      return _this11.getLivethread(result.json.data.id);\n    });\n  }\n  /**\n   * @summary Gets the \"happening now\" LiveThread, if it exists\n   * @desc This is the LiveThread that is occasionally linked at the top of reddit.com, relating to current events.\n   * @returns {Promise} A Promise that fulfills with the \"happening now\" LiveThread if it exists, or rejects with a 404 error\n   otherwise.\n   * @example r.getCurrentEventsLivethread().then(thread => thread.stream.on('update', console.log))\n   */\n\n\n  getStickiedLivethread() {\n    return this._get({\n      uri: 'api/live/happening_now'\n    });\n  }\n  /**\n   * @summary Gets the user's own multireddits.\n   * @returns {Promise} A Promise for an Array containing the requester's MultiReddits.\n   * @example\n   *\n   * r.getMyMultireddits().then(console.log)\n   * => [ MultiReddit { ... }, MultiReddit { ... }, ... ]\n   */\n\n\n  getMyMultireddits() {\n    return this._get({\n      uri: 'api/multi/mine',\n      qs: {\n        expand_srs: true\n      }\n    });\n  }\n  /**\n   * @summary Creates a new multireddit.\n   * @param {object} options\n   * @param {string} options.name The name of the new multireddit. 50 characters max\n   * @param {string} options.description A description for the new multireddit, in markdown.\n   * @param {Array} options.subreddits An Array of Subreddit objects (or subreddit names) that this multireddit should compose of\n   * @param {string} [options.visibility='private'] The multireddit's visibility setting. One of `private`, `public`, `hidden`.\n   * @param {string} [options.icon_name=''] One of `art and design`, `ask`, `books`, `business`, `cars`, `comics`,\n   `cute animals`, `diy`, `entertainment`, `food and drink`, `funny`, `games`, `grooming`, `health`, `life advice`, `military`,\n   `models pinup`, `music`, `news`, `philosophy`, `pictures and gifs`, `science`, `shopping`, `sports`, `style`, `tech`,\n   `travel`, `unusual stories`, `video`, `None`\n   * @param {string} [options.key_color='#000000'] A six-digit RGB hex color, preceded by '#'\n   * @param {string} [options.weighting_scheme='classic'] One of `classic`, `fresh`\n   * @returns {Promise} A Promise for the newly-created MultiReddit object\n   * @example\n   *\n   * r.createMultireddit({\n   *   name: 'myMulti',\n   *   description: 'An example multireddit',\n   *   subreddits: ['snoowrap', 'snoowrap_testing']\n   * }).then(console.log)\n   * => MultiReddit { display_name: 'myMulti', ... }\n   */\n\n\n  createMultireddit(_ref13) {\n    var name = _ref13.name,\n        description = _ref13.description,\n        subreddits = _ref13.subreddits,\n        _ref13$visibility = _ref13.visibility,\n        visibility = _ref13$visibility === void 0 ? 'private' : _ref13$visibility,\n        _ref13$icon_name = _ref13.icon_name,\n        icon_name = _ref13$icon_name === void 0 ? '' : _ref13$icon_name,\n        _ref13$key_color = _ref13.key_color,\n        key_color = _ref13$key_color === void 0 ? '#000000' : _ref13$key_color,\n        _ref13$weighting_sche = _ref13.weighting_scheme,\n        weighting_scheme = _ref13$weighting_sche === void 0 ? 'classic' : _ref13$weighting_sche;\n    return this._post({\n      uri: 'api/multi',\n      form: {\n        model: JSON.stringify({\n          display_name: name,\n          description_md: description,\n          icon_name,\n          key_color,\n          subreddits: subreddits.map(function (sub) {\n            return {\n              name: typeof sub === 'string' ? sub : sub.display_name\n            };\n          }),\n          visibility,\n          weighting_scheme\n        })\n      }\n    });\n  }\n\n  _revokeToken(token) {\n    return this.credentialedClientRequest({\n      uri: 'api/v1/revoke_token',\n      form: {\n        token\n      },\n      method: 'post'\n    });\n  }\n  /**\n   * @summary Invalidates the current access token.\n   * @returns {Promise} A Promise that fulfills when this request is complete\n   * @desc **Note**: This can only be used if the current requester was supplied with a `client_id` and `client_secret`. If the\n   current requester was supplied with a refresh token, it will automatically create a new access token if any more requests\n   are made after this one.\n   * @example r.revokeAccessToken();\n   */\n\n\n  revokeAccessToken() {\n    var _this12 = this;\n\n    return this._revokeToken(this.accessToken).then(function () {\n      _this12.accessToken = null;\n      _this12.tokenExpiration = null;\n    });\n  }\n  /**\n   * @summary Invalidates the current refresh token.\n   * @returns {Promise} A Promise that fulfills when this request is complete\n   * @desc **Note**: This can only be used if the current requester was supplied with a `client_id` and `client_secret`. All\n   access tokens generated by this refresh token will also be invalidated. This effectively de-authenticates the requester and\n   prevents it from making any more valid requests. This should only be used in a few cases, e.g. if this token has\n   been accidentally leaked to a third party.\n   * @example r.revokeRefreshToken();\n   */\n\n\n  revokeRefreshToken() {\n    var _this13 = this;\n\n    return this._revokeToken(this.refreshToken).then(function () {\n      _this13.refreshToken = null;\n      _this13.accessToken = null; // Revoking a refresh token also revokes any associated access tokens.\n\n      _this13.tokenExpiration = null;\n    });\n  }\n\n  _selectFlair(_ref14) {\n    var _this14 = this;\n\n    var flair_template_id = _ref14.flair_template_id,\n        link = _ref14.link,\n        name = _ref14.name,\n        text = _ref14.text,\n        subredditName = _ref14.subredditName;\n\n    if (!flair_template_id) {\n      throw new errors.InvalidMethodCallError('No flair template ID provided');\n    }\n\n    return _Promise.default.resolve(subredditName).then(function (subName) {\n      return _this14._post({\n        uri: \"r/\".concat(subName, \"/api/selectflair\"),\n        form: {\n          api_type,\n          flair_template_id,\n          link,\n          name,\n          text\n        }\n      });\n    });\n  }\n\n  _assignFlair(_ref15) {\n    var _this15 = this;\n\n    var css_class = _ref15.css_class,\n        _ref15$cssClass = _ref15.cssClass,\n        cssClass = _ref15$cssClass === void 0 ? css_class : _ref15$cssClass,\n        link = _ref15.link,\n        name = _ref15.name,\n        text = _ref15.text,\n        subreddit_name = _ref15.subreddit_name,\n        _ref15$subredditName = _ref15.subredditName,\n        subredditName = _ref15$subredditName === void 0 ? subreddit_name : _ref15$subredditName;\n    return this._promiseWrap(_Promise.default.resolve(subredditName).then(function (displayName) {\n      return _this15._post({\n        uri: \"r/\".concat(displayName, \"/api/flair\"),\n        form: {\n          api_type,\n          name,\n          text,\n          link,\n          css_class: cssClass\n        }\n      });\n    }));\n  }\n\n  _populate(responseTree) {\n    var _this16 = this;\n\n    if (typeof responseTree === 'object' && responseTree !== null) {\n      // Map {kind: 't2', data: {name: 'some_username', ... }} to a RedditUser (e.g.) with the same properties\n      if (Object.keys(responseTree).length === 2 && responseTree.kind && responseTree.data) {\n        return this._newObject(_constants.KINDS[responseTree.kind] || 'RedditContent', this._populate(responseTree.data), true);\n      }\n\n      var result = (Array.isArray(responseTree) ? _lodash.map : _lodash.mapValues)(responseTree, function (value, key) {\n        // Maps {author: 'some_username'} to {author: RedditUser { name: 'some_username' } }\n        if (value !== null && _constants.USER_KEYS.has(key)) {\n          return _this16._newObject('RedditUser', {\n            name: value\n          });\n        }\n\n        if (value !== null && _constants.SUBREDDIT_KEYS.has(key)) {\n          return _this16._newObject('Subreddit', {\n            display_name: value\n          });\n        }\n\n        return _this16._populate(value);\n      });\n\n      if (result.length === 2 && result[0] instanceof snoowrap.objects.Listing && result[0][0] instanceof snoowrap.objects.Submission && result[1] instanceof snoowrap.objects.Listing) {\n        if (result[1]._more && !result[1]._more.link_id) {\n          result[1]._more.link_id = result[0][0].name;\n        }\n\n        result[0][0].comments = result[1];\n        return result[0][0];\n      }\n\n      return result;\n    }\n\n    return responseTree;\n  }\n\n  _getListing(_ref16) {\n    var uri = _ref16.uri,\n        _ref16$qs = _ref16.qs,\n        qs = _ref16$qs === void 0 ? {} : _ref16$qs,\n        options = _objectWithoutProperties(_ref16, [\"uri\", \"qs\"]);\n    /* When the response type is expected to be a Listing, add a `count` parameter with a very high number.\n    This ensures that reddit returns a `before` property in the resulting Listing to enable pagination.\n    (Aside from the additional parameter, this function is equivalent to snoowrap.prototype._get) */\n\n\n    var mergedQuery = _objectSpread({\n      count: 9999\n    }, qs);\n\n    return qs.limit || !(0, _lodash.isEmpty)(options) ? this._newObject('Listing', _objectSpread({\n      _query: mergedQuery,\n      _uri: uri\n    }, options)).fetchMore(qs.limit || _constants.MAX_LISTING_ITEMS)\n    /* This second case is used as a fallback in case the endpoint unexpectedly ends up returning something other than a\n    Listing (e.g. Submission#getRelated, which used to return a Listing but no longer does due to upstream reddit API\n    changes), in which case using fetch_more() as above will throw an error.\n     This fallback only works if there are no other meta-properties provided for the Listing, such as _transform. If there are\n    other meta-properties,  the function will still end up throwing an error, but there's not really any good way to handle it\n    (predicting upstream changes can only go so far). More importantly, in the limited cases where it's used, the fallback\n    should have no effect on the returned results */\n    : this._get({\n      uri,\n      qs: mergedQuery\n    }).then(function (listing) {\n      if (Array.isArray(listing)) {\n        listing.filter(function (item) {\n          return item.constructor._name === 'Comment';\n        }).forEach(_helpers.addEmptyRepliesListing);\n      }\n\n      return listing;\n    });\n  }\n  /**\n   * @summary In browsers, restores the `window.snoowrap` property to whatever it was before this instance of snoowrap was\n   loaded. This is a no-op in Node.\n   * @returns This instance of the snoowrap constructor\n   * @example var snoowrap = window.snoowrap.noConflict();\n   */\n\n\n  static noConflict() {\n    if (_helpers.isBrowser) {\n      global[_constants.MODULE_NAME] = this._previousSnoowrap;\n    }\n\n    return this;\n  }\n\n};\n\nfunction identity(value) {\n  return value;\n}\n\n(0, _helpers.defineInspectFunc)(snoowrap.prototype, function () {\n  // Hide confidential information (tokens, client IDs, etc.), as well as private properties, from the console.log output.\n  var keysForHiddenValues = ['clientSecret', 'refreshToken', 'accessToken', 'password'];\n  var formatted = (0, _lodash.mapValues)((0, _lodash.omitBy)(this, function (value, key) {\n    return typeof key === 'string' && key.startsWith('_');\n  }), function (value, key) {\n    return (0, _lodash.includes)(keysForHiddenValues, key) ? value && '(redacted)' : value;\n  });\n  return \"\".concat(_constants.MODULE_NAME, \" \").concat(_util.default.inspect(formatted));\n});\nvar classFuncDescriptors = {\n  configurable: true,\n  writable: true\n};\n/* Add the request_handler functions (oauth_request, credentialed_client_request, etc.) to the snoowrap prototype. Use\nObject.defineProperties to ensure that the properties are non-enumerable. */\n\nObject.defineProperties(snoowrap.prototype, (0, _lodash.mapValues)(requestHandler, function (func) {\n  return _objectSpread({\n    value: func\n  }, classFuncDescriptors);\n}));\n\n_constants.HTTP_VERBS.forEach(function (method) {\n  /* Define method shortcuts for each of the HTTP verbs. i.e. `snoowrap.prototype._post` is the same as `oauth_request` except\n  that the HTTP method defaults to `post`, and the result is promise-wrapped. Use Object.defineProperty to ensure that the\n  properties are non-enumerable. */\n  Object.defineProperty(snoowrap.prototype, \"_\".concat(method), _objectSpread({\n    value(options) {\n      return this._promiseWrap(this.oauthRequest(_objectSpread({}, options, {\n        method\n      })));\n    }\n\n  }, classFuncDescriptors));\n});\n/* `objects` will be an object containing getters for each content type, due to the way objects are exported from\nobjects/index.js. To unwrap these getters into direct properties, use lodash.mapValues with an identity function. */\n\n\nsnoowrap.objects = (0, _lodash.mapValues)(objects, function (value) {\n  return value;\n});\n(0, _lodash.forOwn)(_constants.KINDS, function (value) {\n  snoowrap.objects[value] = snoowrap.objects[value] || class extends objects.RedditContent {};\n  Object.defineProperty(snoowrap.objects[value], '_name', {\n    value,\n    configurable: true\n  });\n}); // Alias all functions on snoowrap's prototype and snoowrap's object prototypes in snake_case.\n\n(0, _lodash.values)(snoowrap.objects).concat(snoowrap).map(function (func) {\n  return func.prototype;\n}).forEach(function (funcProto) {\n  Object.getOwnPropertyNames(funcProto).filter(function (name) {\n    return !name.startsWith('_') && name !== (0, _lodash.snakeCase)(name) && typeof funcProto[name] === 'function';\n  }).forEach(function (name) {\n    return Object.defineProperty(funcProto, (0, _lodash.snakeCase)(name), _objectSpread({\n      value: funcProto[name]\n    }, classFuncDescriptors));\n  });\n});\nsnoowrap.errors = errors;\nsnoowrap.version = _constants.VERSION;\n\nif (!module.parent && _helpers.isBrowser) {\n  // check if the code is being run in a browser through browserify, etc.\n  snoowrap._previousSnoowrap = global[_constants.MODULE_NAME];\n  global[_constants.MODULE_NAME] = snoowrap;\n}\n\nmodule.exports = snoowrap;","map":{"version":3,"sources":["/Users/simranbhake/Desktop/ProjectProgress/8. savedit/node_modules/snoowrap/dist/snoowrap.js"],"names":["_lodash","require","_Promise","_interopRequireDefault","_promiseChains","_util","requestHandler","_interopRequireWildcard","_constants","errors","_helpers","_create_config","objects","obj","__esModule","newObj","key","Object","prototype","hasOwnProperty","call","desc","defineProperty","getOwnPropertyDescriptor","get","set","default","_objectWithoutProperties","source","excluded","target","_objectWithoutPropertiesLoose","i","getOwnPropertySymbols","sourceSymbolKeys","length","indexOf","propertyIsEnumerable","sourceKeys","keys","ownKeys","object","enumerableOnly","symbols","filter","sym","enumerable","push","apply","_objectSpread","arguments","forEach","_defineProperty","getOwnPropertyDescriptors","defineProperties","value","configurable","writable","api_type","snoowrap","constructor","_ref","undefined","user_agent","_ref$userAgent","userAgent","client_id","_ref$clientId","clientId","client_secret","_ref$clientSecret","clientSecret","refresh_token","_ref$refreshToken","refreshToken","access_token","_ref$accessToken","accessToken","username","password","isBrowser","requiredArg","NoCredentialsError","global","navigator","defaults","ratelimitRemaining","ratelimitExpiration","tokenExpiration","scope","_config","_nextRequestTimestamp","Infinity","addSnakeCaseShadowProps","getAuthUrl","_ref2","_ref2$clientId","_ref2$scope","_ref2$redirectUri","redirectUri","_ref2$permanent","permanent","_ref2$state","state","_ref2$endpointDomain","endpointDomain","Array","isArray","every","scopeValue","TypeError","concat","encodeURIComponent","join","replace","fromAuthCode","_ref3","_this","_ref3$code","code","_ref3$userAgent","_ref3$clientId","_ref3$redirectUri","_ref3$endpointDomain","credentialedClientRequest","rawRequest","method","baseUrl","uri","form","grant_type","redirect_uri","then","response","error","RequestError","error_description","requester","config","grantType","CLIENT_CREDENTIALS","INSTALLED_CLIENT","fromApplicationOnlyAuth","_ref4","_this2","_ref4$userAgent","_ref4$clientId","deviceId","_ref4$grantType","_ref4$permanent","_ref4$endpointDomain","device_id","duration","_newObject","objectType","content","_hasFetched","_this3","options","invalidKey","find","assign","_warn","warnings","_console","_len","args","_key","console","warn","_debug","debug","_console2","_len2","_key2","log","_promiseWrap","proxies","identity","getUser","name","getComment","commentId","addFullnamePrefix","getSubreddit","displayName","display_name","getSubmission","submissionId","getMessage","messageId","getLivethread","threadId","id","slice","getMe","_this4","_get","result","_ownUserInfo","_getMyName","resolve","getKarma","getPreferences","updatePreferences","updatedPreferences","_patch","body","getMyTrophies","getFriends","getBlockedUsers","checkCaptchaRequirement","getNewCaptchaIdentifier","_post","res","json","data","iden","getCaptchaImage","identifier","getSavedCategories","markAsVisited","links","map","_submit","_ref5","_this5","captcha_response","_ref5$captchaResponse","captchaResponse","captcha_iden","_ref5$captchaIden","captchaIden","kind","_ref5$resubmit","resubmit","_ref5$send_replies","send_replies","_ref5$sendReplies","sendReplies","crosspost_fullname","text","title","url","subreddit_name","_ref5$subredditName","subredditName","captcha","sendreplies","sr","tap","handleJsonErrors","submitSelfpost","submitLink","submitCrosspost","originalPost","Submission","_getSortedFrontpage","sortType","opts","subName","isEmpty","omitBy","option","parsedOptions","omit","t","time","_getListing","qs","getHot","getBest","getNew","getNewComments","getContentByIds","ids","prefixedIds","Comment","test","getRandomSubmission","getTop","getControversial","getRising","getUnreadMessages","getInbox","_ref6","getModmail","getNewModmailConversations","_this6","_name","_transform","after","before","children","conversation","conversationIds","conversations","participant","conversationObjects","ModmailConversation","_getConversationObjects","createModmailDiscussion","_ref7","_this7","subject","srName","parsedFromSr","getNewModmailConversation","markNewModmailConversationsAsRead","message","markNewModmailConversationsAsUnread","getNewModmailSubreddits","_this8","values","subreddits","s","getUnreadNewModmailConversationsCount","bulkReadNewModmail","_this9","subredditNames","entity","conversation_ids","getSentMessages","markMessagesAsRead","messages","messageIds","markMessagesAsUnread","readAllMessages","composeMessage","_ref8","from_subreddit","_ref8$fromSubreddit","fromSubreddit","_ref8$captchaIden","to","parsedTo","RedditUser","Subreddit","from_sr","return","getOauthScopeList","search","subreddit","restrictSr","syntax","parsedQuery","q","query","restrict_sr","searchSubredditNames","_ref9","_ref9$exact","exact","_ref9$include_nsfw","include_nsfw","_ref9$includeNsfw","includeNsfw","include_over_18","_createOrEditSubreddit","_ref10","_ref10$allow_images","allow_images","_ref10$allow_top","allow_top","_ref10$collapse_delet","collapse_deleted_comments","_ref10$comment_score_","comment_score_hide_mins","description","_ref10$exclude_banned","exclude_banned_modqueue","header_title","_ref10$hide_ads","hide_ads","_ref10$lang","lang","_ref10$link_type","link_type","_ref10$over_","over_18","public_description","_ref10$public_traffic","public_traffic","_ref10$show_media","show_media","_ref10$show_media_pre","show_media_preview","_ref10$spam_comments","spam_comments","_ref10$spam_links","spam_links","_ref10$spam_selfposts","spam_selfposts","_ref10$spoilers_enabl","spoilers_enabled","_ref10$submit_link_la","submit_link_label","_ref10$submit_text_la","submit_text_label","_ref10$submit_text","submit_text","_ref10$suggested_comm","suggested_comment_sort","_ref10$type","type","wiki_edit_age","wiki_edit_karma","_ref10$wikimode","wikimode","createSubreddit","searchSubredditTopics","_ref11","_this10","getSubscriptions","getContributorSubreddits","getModeratedSubreddits","searchSubreddits","getPopularSubreddits","getNewSubreddits","getGoldSubreddits","getDefaultSubreddits","checkUsernameAvailability","unauthenticatedRequest","user","createLivethread","_ref12","_this11","resources","_ref12$nsfw","nsfw","getStickiedLivethread","getMyMultireddits","expand_srs","createMultireddit","_ref13","_ref13$visibility","visibility","_ref13$icon_name","icon_name","_ref13$key_color","key_color","_ref13$weighting_sche","weighting_scheme","model","JSON","stringify","description_md","sub","_revokeToken","token","revokeAccessToken","_this12","revokeRefreshToken","_this13","_selectFlair","_ref14","_this14","flair_template_id","link","InvalidMethodCallError","_assignFlair","_ref15","_this15","css_class","_ref15$cssClass","cssClass","_ref15$subredditName","_populate","responseTree","_this16","KINDS","mapValues","USER_KEYS","has","SUBREDDIT_KEYS","Listing","_more","link_id","comments","_ref16","_ref16$qs","mergedQuery","count","limit","_query","_uri","fetchMore","MAX_LISTING_ITEMS","listing","item","addEmptyRepliesListing","noConflict","MODULE_NAME","_previousSnoowrap","defineInspectFunc","keysForHiddenValues","formatted","startsWith","includes","inspect","classFuncDescriptors","func","HTTP_VERBS","oauthRequest","forOwn","RedditContent","funcProto","getOwnPropertyNames","snakeCase","version","VERSION","module","parent","exports"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _lodash = require(\"lodash\");\n\nvar _Promise = _interopRequireDefault(require(\"./Promise.js\"));\n\nvar _promiseChains = _interopRequireDefault(require(\"promise-chains\"));\n\nvar _util = _interopRequireDefault(require(\"util\"));\n\nvar requestHandler = _interopRequireWildcard(require(\"./request_handler.js\"));\n\nvar _constants = require(\"./constants.js\");\n\nvar errors = _interopRequireWildcard(require(\"./errors.js\"));\n\nvar _helpers = require(\"./helpers.js\");\n\nvar _create_config = _interopRequireDefault(require(\"./create_config.js\"));\n\nvar objects = _interopRequireWildcard(require(\"./objects/index.js\"));\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar api_type = 'json';\n/** The class for a snoowrap requester.\n * A requester is the base object that is used to fetch content from reddit. Each requester contains a single set of OAuth\n tokens.\n\n If constructed with a refresh token, a requester will be able to repeatedly generate access tokens as necessary, without any\n further user intervention. After making at least one request, a requester will have the `access_token` property, which specifies\n the access token currently in use. It will also have a few additional properties such as `scope` (an array of scope strings)\n and `ratelimitRemaining` (the number of requests remaining for the current 10-minute interval, in compliance with reddit's\n [API rules](https://github.com/reddit/reddit/wiki/API).) These properties primarily exist for internal use, but they are\n exposed since they are useful externally as well.\n */\n\nvar snoowrap = class snoowrap {\n  /**\n   * @summary Constructs a new requester.\n   * @desc You should use the snoowrap constructor if you are able to authorize a reddit account in advance (e.g. for a Node.js\n   script that always uses the same account). If you aren't able to authorize in advance (e.g. acting through an arbitrary user's\n   account while running snoowrap in a browser), then you should use {@link snoowrap.getAuthUrl} and\n   {@link snoowrap.fromAuthCode} instead.\n   *\n   * To edit snoowrap specific settings, see {@link snoowrap#config}.\n   *\n   * snoowrap supports several different options for pre-existing authentication:\n   * 1. *Refresh token*: To authenticate with a refresh token, pass an object with the properties `userAgent`, `clientId`,\n   `clientSecret`, and `refreshToken` to the snoowrap constructor. You will need to get the refresh token from reddit\n   beforehand. A script to automatically generate refresh tokens for you can be found\n   [here](https://github.com/not-an-aardvark/reddit-oauth-helper).\n   * 1. *Username/password*: To authenticate with a username and password, pass an object with the properties `userAgent`,\n   `clientId`, `clientSecret`, `username`, and `password` to the snoowrap constructor. Note that username/password\n   authentication is only possible for `script`-type apps.\n   * 1. *Access token*: To authenticate with an access token, pass an object with the properties `userAgent` and `accessToken`\n   to the snoowrap constructor. Note that all access tokens expire one hour after being generated, so this method is\n   not recommended for long-term use.\n   * @param {object} options An object containing authentication options. This should always have the property `userAgent`. It\n   must also contain some combination of credentials (see above)\n   * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n   is running in a browser.\n   * @param {string} [options.clientId] The client ID of your app (assigned by reddit)\n   * @param {string} [options.clientSecret] The client secret of your app (assigned by reddit). If you are using a refresh token\n   with an installed app (which does not have a client secret), pass an empty string as your `clientSecret`.\n   * @param {string} [options.username] The username of the account to access\n   * @param {string} [options.password] The password of the account to access\n   * @param {string} [options.refreshToken] A refresh token for your app\n   * @param {string} [options.accessToken] An access token for your app\n   */\n  constructor() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        user_agent = _ref.user_agent,\n        _ref$userAgent = _ref.userAgent,\n        userAgent = _ref$userAgent === void 0 ? user_agent : _ref$userAgent,\n        client_id = _ref.client_id,\n        _ref$clientId = _ref.clientId,\n        clientId = _ref$clientId === void 0 ? client_id : _ref$clientId,\n        client_secret = _ref.client_secret,\n        _ref$clientSecret = _ref.clientSecret,\n        clientSecret = _ref$clientSecret === void 0 ? client_secret : _ref$clientSecret,\n        refresh_token = _ref.refresh_token,\n        _ref$refreshToken = _ref.refreshToken,\n        refreshToken = _ref$refreshToken === void 0 ? refresh_token : _ref$refreshToken,\n        access_token = _ref.access_token,\n        _ref$accessToken = _ref.accessToken,\n        accessToken = _ref$accessToken === void 0 ? access_token : _ref$accessToken,\n        username = _ref.username,\n        password = _ref.password;\n\n    if (!userAgent && !_helpers.isBrowser) {\n      return (0, _helpers.requiredArg)('userAgent');\n    }\n\n    if ((!accessToken || typeof accessToken !== 'string') && (clientId === undefined || clientSecret === undefined || typeof refreshToken !== 'string') && (clientId === undefined || clientSecret === undefined || username === undefined || password === undefined)) {\n      throw new errors.NoCredentialsError();\n    }\n\n    if (_helpers.isBrowser) {\n      this.userAgent = global.navigator.userAgent;\n    }\n\n    (0, _lodash.defaults)(this, {\n      userAgent,\n      clientId,\n      clientSecret,\n      refreshToken,\n      accessToken,\n      username,\n      password\n    }, {\n      clientId: null,\n      clientSecret: null,\n      refreshToken: null,\n      accessToken: null,\n      username: null,\n      password: null,\n      ratelimitRemaining: null,\n      ratelimitExpiration: null,\n      tokenExpiration: null,\n      scope: null,\n      _config: (0, _create_config.default)(),\n      _nextRequestTimestamp: -Infinity\n    });\n    (0, _helpers.addSnakeCaseShadowProps)(this);\n  }\n  /**\n   * @summary Gets an authorization URL, which allows a user to authorize access to their account\n   * @desc This create a URL where a user can authorize an app to act through their account. If the user visits the returned URL\n   in a web browser, they will see a page that looks like [this](https://i.gyazo.com/0325534f38b78c1dbd4c84d690dda6c2.png). If\n   the user clicks \"Allow\", they will be redirected to your `redirectUri`, with a `code` querystring parameter containing an\n   * *authorization code*. If this code is passed to {@link snoowrap.fromAuthCode}, you can create a requester to make\n   requests on behalf of the user.\n   *\n   * The main use-case here is for running snoowrap in a browser. You can generate a URL, send the user there, and then continue\n   after the user authenticates on reddit and is redirected back.\n   *\n   * @param {object} options\n   * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n   browser, using an \"Installed\" app type is recommended.\n   * @param {string[]} options.scope An array of scopes (permissions on the user's account) to request on the authentication\n   page. A list of possible scopes can be found [here](https://www.reddit.com/api/v1/scopes). You can also get them on-the-fly\n   with {@link snoowrap#getOauthScopeList}.\n   * @param {string} options.redirectUri The URL where the user should be redirected after authenticating. This **must** be the\n   same as the redirect URI that is configured for the reddit app. (If there is a mismatch, the returned URL will display an\n   error page instead of an authentication form.)\n   * @param {boolean} [options.permanent=true] If `true`, the app will have indefinite access to the user's account. If `false`,\n   access to the user's account will expire after 1 hour.\n   * @param {string} [options.state] A string that can be used to verify a user after they are redirected back to the site. When\n   the user is redirected from reddit, to the redirect URI after authenticating, the resulting URI will have this same `state`\n   value in the querystring. (See [here](http://www.twobotechnologies.com/blog/2014/02/importance-of-state-in-oauth2.html) for\n   more information on how to use the `state` value.)\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain for the URL. If the user is authenticating on\n   reddit.com (as opposed to some other site with a reddit-like API), you can omit this value.\n   * @returns {string} A URL where the user can authenticate with the given options\n   * @example\n   *\n   * var authenticationUrl = snoowrap.getAuthUrl({\n   *   clientId: 'foobarbazquuux',\n   *   scope: ['identity', 'wikiread', 'wikiedit'],\n   *   redirectUri: 'https://example.com/reddit_callback',\n   *   permanent: false,\n   *   state: 'fe211bebc52eb3da9bef8db6e63104d3' // a random string, this could be validated when the user is redirected back\n   * });\n   * // --> 'https://www.reddit.com/api/v1/authorize?client_id=foobarbaz&response_type=code&state= ...'\n   *\n   * window.location = authenticationUrl; // send the user to the authentication url\n   */\n\n\n  static getAuthUrl(_ref2) {\n    var _ref2$clientId = _ref2.clientId,\n        clientId = _ref2$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref2$clientId,\n        _ref2$scope = _ref2.scope,\n        scope = _ref2$scope === void 0 ? (0, _helpers.requiredArg)('scope') : _ref2$scope,\n        _ref2$redirectUri = _ref2.redirectUri,\n        redirectUri = _ref2$redirectUri === void 0 ? (0, _helpers.requiredArg)('redirectUri') : _ref2$redirectUri,\n        _ref2$permanent = _ref2.permanent,\n        permanent = _ref2$permanent === void 0 ? true : _ref2$permanent,\n        _ref2$state = _ref2.state,\n        state = _ref2$state === void 0 ? '_' : _ref2$state,\n        _ref2$endpointDomain = _ref2.endpointDomain,\n        endpointDomain = _ref2$endpointDomain === void 0 ? 'reddit.com' : _ref2$endpointDomain;\n\n    if (!(Array.isArray(scope) && scope.length && scope.every(function (scopeValue) {\n      return scopeValue && typeof scopeValue === 'string';\n    }))) {\n      throw new TypeError('Missing `scope` argument; a non-empty list of OAuth scopes must be provided');\n    }\n\n    return \"\\n      https://www.\".concat(endpointDomain, \"/api/v1/authorize?\\n      client_id=\").concat(encodeURIComponent(clientId), \"\\n      &response_type=code\\n      &state=\").concat(encodeURIComponent(state), \"\\n      &redirect_uri=\").concat(encodeURIComponent(redirectUri), \"\\n      &duration=\").concat(permanent ? 'permanent' : 'temporary', \"\\n      &scope=\").concat(encodeURIComponent(scope.join(' ')), \"\\n    \").replace(/\\s/g, '');\n  }\n  /**\n   * @summary Creates a snoowrap requester from an authorization code.\n   * @desc An authorization code is the `code` value that appears in the querystring after a user authenticates with reddit and\n   is redirected. For more information, see {@link snoowrap.getAuthUrl}.\n   *\n   * The main use-case for this function is for running snoowrap in a browser. You can generate a URL with\n   {@link snoowrap.getAuthUrl} and send the user to that URL, and then use this function to create a requester when\n   the user is redirected back with an authorization code.\n   * @param {object} options\n   * @param {string} options.code The authorization code\n   * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n   is running in a browser.\n   * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n   browser, using an \"Installed\" app type is recommended.\n   * @param {string} [options.clientSecret] The client secret of your app. If your app has the \"Installed\" app type, omit\n   this parameter.\n   * @param {string} options.redirectUri The redirect URI that is configured for the reddit app.\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain that the returned requester should be configured\n   to use. If the user is authenticating on reddit.com (as opposed to some other site with a reddit-like API), you can omit this\n   value.\n   * @returns {Promise<snoowrap>} A Promise that fulfills with a `snoowrap` instance\n   * @example\n   *\n   * // Get the `code` querystring param (assuming the user was redirected from reddit)\n   * var code = new URL(window.location.href).searchParams.get('code');\n   *\n   * snoowrap.fromAuthCode({\n   *   code: code,\n   *   userAgent: 'My app',\n   *   clientId: 'foobarbazquuux',\n   *   redirectUri: 'example.com'\n   * }).then(r => {\n   *   // Now we have a requester that can access reddit through the user's account\n   *   return r.getHot().then(posts => {\n   *     // do something with posts from the front page\n   *   });\n   * })\n   */\n\n\n  static fromAuthCode(_ref3) {\n    var _this = this;\n\n    var _ref3$code = _ref3.code,\n        code = _ref3$code === void 0 ? (0, _helpers.requiredArg)('code') : _ref3$code,\n        _ref3$userAgent = _ref3.userAgent,\n        userAgent = _ref3$userAgent === void 0 ? _helpers.isBrowser ? global.navigator.userAgent : (0, _helpers.requiredArg)('userAgent') : _ref3$userAgent,\n        _ref3$clientId = _ref3.clientId,\n        clientId = _ref3$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref3$clientId,\n        clientSecret = _ref3.clientSecret,\n        _ref3$redirectUri = _ref3.redirectUri,\n        redirectUri = _ref3$redirectUri === void 0 ? (0, _helpers.requiredArg)('redirectUri') : _ref3$redirectUri,\n        _ref3$endpointDomain = _ref3.endpointDomain,\n        endpointDomain = _ref3$endpointDomain === void 0 ? 'reddit.com' : _ref3$endpointDomain;\n    return this.prototype.credentialedClientRequest.call({\n      userAgent,\n      clientId,\n      clientSecret,\n      // Use `this.prototype.rawRequest` function to allow for custom `rawRequest` method usage in subclasses.\n      rawRequest: this.prototype.rawRequest\n    }, {\n      method: 'post',\n      baseUrl: \"https://www.\".concat(endpointDomain, \"/\"),\n      uri: 'api/v1/access_token',\n      form: {\n        grant_type: 'authorization_code',\n        code,\n        redirect_uri: redirectUri\n      }\n    }).then(function (response) {\n      if (response.error) {\n        throw new errors.RequestError(\"API Error: \".concat(response.error, \" - \").concat(response.error_description));\n      } // Use `new this` instead of `new snoowrap` to ensure that subclass instances can be returned\n\n\n      var requester = new _this(_objectSpread({\n        userAgent,\n        clientId,\n        clientSecret\n      }, response));\n      requester.config({\n        endpointDomain\n      });\n      return requester;\n    });\n  }\n  /**\n   * @summary Returns the grant types available for app-only authentication\n   * @desc Per the Reddit API OAuth docs, there are two different grant types depending on whether the app is an installed client\n   * or a confidential client such as a web app or string. This getter returns the possible values for the \"grant_type\" field\n   * in application-only auth.\n   * @returns {object} The enumeration of possible grant_type values\n   */\n\n\n  static get grantType() {\n    return {\n      CLIENT_CREDENTIALS: 'client_credentials',\n      INSTALLED_CLIENT: 'https://oauth.reddit.com/grants/installed_client'\n    };\n  }\n  /**\n  * @summary Creates a snoowrap requester from a \"user-less\" Authorization token\n  * @desc In some cases, 3rd party app clients may wish to make API requests without a user context. App clients can request\n  * a \"user-less\" Authorization token via either the standard client_credentials grant, or the reddit specific\n  * extension to this grant, https://oauth.reddit.com/grants/installed_client. Which grant type an app uses depends on\n  * the app-type and its use case.\n  * @param {object} options\n  * @param {string} options.userAgent A unique description of what your app does. This argument is not necessary when snoowrap\n  is running in a browser.\n  * @param {string} options.clientId The client ID of your app (assigned by reddit). If your code is running clientside in a\n  * browser, using an \"Installed\" app type is recommended.\n  * @param {string} [options.clientSecret] The client secret of your app. Only required for \"client_credentials\" grant type.\n  * @param {string} [options.deviceId] A unique, per-device ID generated by your client. Only required\n  * for \"Installed\" grant type, needs to be between 20-30 characters long. From the reddit docs: \"reddit *may* choose to use\n  * this ID to generate aggregate data about user counts. Clients that wish to remain anonymous should use the value\n  * DO_NOT_TRACK_THIS_DEVICE.\"\n  * @param {string} [options.grantType=snoowrap.grantType.INSTALLED_CLIENT] The type of \"user-less\"\n  * token to use {@link snoowrap.grantType}\n  * @param {boolean} [options.permanent=true] If `true`, the app will have indefinite access. If `false`,\n  access will expire after 1 hour.\n  * @param {string} [options.endpointDomain='reddit.com'] The endpoint domain that the returned requester should be configured\n  to use. If the user is authenticating on reddit.com (as opposed to some other site with a reddit-like API), you can omit this\n  value.\n  * @returns {Promise<snoowrap>} A Promise that fulfills with a `snoowrap` instance\n  * @example\n  *\n  * snoowrap.fromApplicationOnlyAuth({\n  *   userAgent: 'My app',\n  *   clientId: 'foobarbazquuux',\n  *   deviceId: 'unique id between 20-30 chars'\n  *   grantType: snoowrap.grantType.INSTALLED_CLIENT\n  * }).then(r => {\n  *   // Now we have a requester that can access reddit through a \"user-less\" Auth token\n  *   return r.getHot().then(posts => {\n  *     // do something with posts from the front page\n  *   });\n  * })\n  *\n  * snoowrap.fromApplicationOnlyAuth({\n  *   userAgent: 'My app',\n  *   clientId: 'foobarbazquuux',\n  *   clientSecret: 'your web app secret'\n  *   grantType: snoowrap.grantType.CLIENT_CREDENTIALS\n  * }).then(r => {\n  *   // Now we have a requester that can access reddit through a \"user-less\" Auth token\n  *   return r.getHot().then(posts => {\n  *     // do something with posts from the front page\n  *   });\n  * })\n  */\n\n\n  static fromApplicationOnlyAuth(_ref4) {\n    var _this2 = this;\n\n    var _ref4$userAgent = _ref4.userAgent,\n        userAgent = _ref4$userAgent === void 0 ? _helpers.isBrowser ? global.navigator.userAgent : (0, _helpers.requiredArg)('userAgent') : _ref4$userAgent,\n        _ref4$clientId = _ref4.clientId,\n        clientId = _ref4$clientId === void 0 ? (0, _helpers.requiredArg)('clientId') : _ref4$clientId,\n        clientSecret = _ref4.clientSecret,\n        deviceId = _ref4.deviceId,\n        _ref4$grantType = _ref4.grantType,\n        grantType = _ref4$grantType === void 0 ? snoowrap.grantType.INSTALLED_CLIENT : _ref4$grantType,\n        _ref4$permanent = _ref4.permanent,\n        permanent = _ref4$permanent === void 0 ? true : _ref4$permanent,\n        _ref4$endpointDomain = _ref4.endpointDomain,\n        endpointDomain = _ref4$endpointDomain === void 0 ? 'reddit.com' : _ref4$endpointDomain;\n    return this.prototype.credentialedClientRequest.call({\n      clientId,\n      clientSecret,\n      // Use `this.prototype.rawRequest` function to allow for custom `rawRequest` method usage in subclasses.\n      rawRequest: this.prototype.rawRequest\n    }, {\n      method: 'post',\n      baseUrl: \"https://www.\".concat(endpointDomain, \"/\"),\n      uri: 'api/v1/access_token',\n      form: {\n        grant_type: grantType,\n        device_id: deviceId,\n        duration: permanent ? 'permanent' : 'temporary'\n      }\n    }).then(function (response) {\n      if (response.error) {\n        throw new errors.RequestError(\"API Error: \".concat(response.error, \" - \").concat(response.error_description));\n      } // Use `new this` instead of `new snoowrap` to ensure that subclass instances can be returned\n\n\n      var requester = new _this2(_objectSpread({\n        userAgent,\n        clientId,\n        clientSecret\n      }, response));\n      requester.config({\n        endpointDomain\n      });\n      return requester;\n    });\n  }\n\n  _newObject(objectType, content) {\n    var _hasFetched = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    return Array.isArray(content) ? content : new snoowrap.objects[objectType](content, this, _hasFetched);\n  }\n  /**\n   * @summary Retrieves or modifies the configuration options for this snoowrap instance.\n   * @param {object} [options] A map of `{[config property name]: value}`. Note that any omitted config properties will simply\n   retain whatever value they had previously. (In other words, if you only want to change one property, you only need to put\n   that one property in this parameter. To get the current configuration without modifying anything, simply omit this\n   parameter.)\n   * @param {string} [options.endpointDomain='reddit.com'] The endpoint where requests should be sent\n   * @param {Number} [options.requestDelay=0] A minimum delay, in milliseconds, to enforce between API calls. If multiple\n   api calls are requested during this timespan, they will be queued and sent one at a time. Setting this to more than 1000 will\n   ensure that reddit's ratelimit is never reached, but it will make things run slower than necessary if only a few requests\n   are being sent. If this is set to zero, snoowrap will not enforce any delay between individual requests. However, it will\n   still refuse to continue if reddit's enforced ratelimit (600 requests per 10 minutes) is exceeded.\n   * @param {Number} [options.requestTimeout=30000] A timeout for all OAuth requests, in milliseconds. If the reddit server\n   fails to return a response within this amount of time, the Promise will be rejected with a timeout error.\n   * @param {boolean} [options.continueAfterRatelimitError=false] Determines whether snoowrap should queue API calls if\n   reddit's ratelimit is exceeded. If set to `true` when the ratelimit is exceeded, snoowrap will queue all further requests,\n   and will attempt to send them again after the current ratelimit period expires (which happens every 10 minutes). If set\n   to `false`, snoowrap will simply throw an error when reddit's ratelimit is exceeded.\n   * @param {Number[]} [options.retryErrorCodes=[502, 503, 504, 522]] If reddit responds to an idempotent request with one of\n   these error codes, snoowrap will retry the request, up to a maximum of `max_retry_attempts` requests in total. (These\n   errors usually indicate that there was an temporary issue on reddit's end, and retrying the request has a decent chance of\n   success.) This behavior can be disabled by simply setting this property to an empty array.\n   * @param {Number} [options.maxRetryAttempts=3] See `retryErrorCodes`.\n   * @param {boolean} [options.warnings=true] snoowrap may occasionally log warnings, such as deprecation notices, to the\n   console. These can be disabled by setting this to `false`.\n   * @param {boolean} [options.debug=false] If set to true, snoowrap will print out potentially-useful information for debugging\n   purposes as it runs.\n   * @param {boolean} [options.proxies=true] Setting this to `false` disables snoowrap's method-chaining feature. This causes\n   the syntax for using snoowrap to become a bit heavier, but allows for consistency between environments that support the ES6\n   `Proxy` object and environments that don't. This option is a no-op in environments that don't support the `Proxy` object,\n   since method chaining is always disabled in those environments. Note, changing this setting must be done before making\n   any requests.\n   * @returns {object} An updated Object containing all of the configuration values\n   * @example\n   *\n   * r.config({requestDelay: 1000, warnings: false});\n   * // sets the request delay to 1000 milliseconds, and suppresses warnings.\n   */\n\n\n  config() {\n    var _this3 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var invalidKey = Object.keys(options).find(function (key) {\n      return !(key in _this3._config);\n    });\n\n    if (invalidKey) {\n      throw new TypeError(\"Invalid config option '\".concat(invalidKey, \"'\"));\n    }\n\n    return Object.assign(this._config, options);\n  }\n\n  _warn() {\n    if (this._config.warnings) {\n      var _console;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      (_console = console).warn.apply(_console, ['[warning]'].concat(args)); // eslint-disable-line no-console\n\n    }\n  }\n\n  _debug() {\n    if (this._config.debug) {\n      var _console2;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      (_console2 = console).log.apply(_console2, ['[debug]'].concat(args)); // eslint-disable-line no-console\n\n    }\n  }\n\n  get _promiseWrap() {\n    return this._config.proxies ? _promiseChains.default : identity;\n  }\n  /**\n   * @summary Gets information on a reddit user with a given name.\n   * @param {string} name - The user's username\n   * @returns {RedditUser} An unfetched RedditUser object for the requested user\n   * @example\n   *\n   * r.getUser('not_an_aardvark')\n   * // => RedditUser { name: 'not_an_aardvark' }\n   * r.getUser('not_an_aardvark').link_karma.then(console.log)\n   * // => 6\n   */\n\n\n  getUser(name) {\n    return this._newObject('RedditUser', {\n      name: (name + '').replace(/^\\/?u\\//, '')\n    });\n  }\n  /**\n   * @summary Gets information on a comment with a given id.\n   * @param {string} commentId - The base36 id of the comment\n   * @returns {Comment} An unfetched Comment object for the requested comment\n   * @example\n   *\n   * r.getComment('c0b6xx0')\n   * // => Comment { name: 't1_c0b6xx0' }\n   * r.getComment('c0b6xx0').author.name.then(console.log)\n   * // => 'Kharos'\n   */\n\n\n  getComment(commentId) {\n    return this._newObject('Comment', {\n      name: (0, _helpers.addFullnamePrefix)(commentId, 't1_')\n    });\n  }\n  /**\n   * @summary Gets information on a given subreddit.\n   * @param {string} displayName - The name of the subreddit (e.g. 'AskReddit')\n   * @returns {Subreddit} An unfetched Subreddit object for the requested subreddit\n   * @example\n   *\n   * r.getSubreddit('AskReddit')\n   * // => Subreddit { display_name: 'AskReddit' }\n   * r.getSubreddit('AskReddit').created_utc.then(console.log)\n   * // => 1201233135\n   */\n\n\n  getSubreddit(displayName) {\n    return this._newObject('Subreddit', {\n      display_name: displayName.replace(/^\\/?r\\//, '')\n    });\n  }\n  /**\n   * @summary Gets information on a given submission.\n   * @param {string} submissionId - The base36 id of the submission\n   * @returns {Submission} An unfetched Submission object for the requested submission\n   * @example\n   *\n   * r.getSubmission('2np694')\n   * // => Submission { name: 't3_2np694' }\n   * r.getSubmission('2np694').title.then(console.log)\n   * // => 'What tasty food would be distusting if eaten over rice?'\n   */\n\n\n  getSubmission(submissionId) {\n    return this._newObject('Submission', {\n      name: (0, _helpers.addFullnamePrefix)(submissionId, 't3_')\n    });\n  }\n  /**\n   * @summary Gets a private message by ID.\n   * @param {string} messageId The base36 ID of the message\n   * @returns {PrivateMessage} An unfetched PrivateMessage object for the requested message\n   * @example\n   *\n   * r.getMessage('51shnw')\n   * // => PrivateMessage { name: 't4_51shnw' }\n   * r.getMessage('51shnw').subject.then(console.log)\n   * // => 'Example'\n   * // See here for a screenshot of the PM in question https://i.gyazo.com/24f3b97e55b6ff8e3a74cb026a58b167.png\n   */\n\n\n  getMessage(messageId) {\n    return this._newObject('PrivateMessage', {\n      name: (0, _helpers.addFullnamePrefix)(messageId, 't4_')\n    });\n  }\n  /**\n   * Gets a livethread by ID.\n   * @param {string} threadId The base36 ID of the livethread\n   * @returns {LiveThread} An unfetched LiveThread object\n   * @example\n   *\n   * r.getLivethread('whrdxo8dg9n0')\n   * // => LiveThread { id: 'whrdxo8dg9n0' }\n   * r.getLivethread('whrdxo8dg9n0').nsfw.then(console.log)\n   * // => false\n   */\n\n\n  getLivethread(threadId) {\n    return this._newObject('LiveThread', {\n      id: (0, _helpers.addFullnamePrefix)(threadId, 'LiveUpdateEvent_').slice(16)\n    });\n  }\n  /**\n   * @summary Gets information on the requester's own user profile.\n   * @returns {RedditUser} A RedditUser object corresponding to the requester's profile\n   * @example\n   *\n   * r.getMe().then(console.log);\n   * // => RedditUser { is_employee: false, has_mail: false, name: 'snoowrap_testing', ... }\n   */\n\n\n  getMe() {\n    var _this4 = this;\n\n    return this._get({\n      uri: 'api/v1/me'\n    }).then(function (result) {\n      _this4._ownUserInfo = _this4._newObject('RedditUser', result, true);\n      return _this4._ownUserInfo;\n    });\n  }\n\n  _getMyName() {\n    return _Promise.default.resolve(this._ownUserInfo ? this._ownUserInfo.name : this.getMe().get('name'));\n  }\n  /**\n   * @summary Gets a distribution of the requester's own karma distribution by subreddit.\n   * @returns {Promise} A Promise for an object with karma information\n   * @example\n   *\n   * r.getKarma().then(console.log)\n   * // => [\n   * //  { sr: Subreddit { display_name: 'redditdev' }, comment_karma: 16, link_karma: 1 },\n   * //  { sr: Subreddit { display_name: 'programming' }, comment_karma: 2, link_karma: 1 },\n   * //  ...\n   * // ]\n   */\n\n\n  getKarma() {\n    return this._get({\n      uri: 'api/v1/me/karma'\n    });\n  }\n  /**\n   * @summary Gets information on the user's current preferences.\n   * @returns {Promise} A promise for an object containing the user's current preferences\n   * @example\n   *\n   * r.getPreferences().then(console.log)\n   * // => { default_theme_sr: null, threaded_messages: true, hide_downs: false, ... }\n   */\n\n\n  getPreferences() {\n    return this._get({\n      uri: 'api/v1/me/prefs'\n    });\n  }\n  /**\n   * @summary Updates the user's current preferences.\n   * @param {object} updatedPreferences An object of the form {[some preference name]: 'some value', ...}. Any preference\n   * not included in this object will simply retain its current value.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.updatePreferences({threaded_messages: false, hide_downs: true})\n   * // => { default_theme_sr: null, threaded_messages: false,hide_downs: true, ... }\n   * // (preferences updated on reddit)\n   */\n\n\n  updatePreferences(updatedPreferences) {\n    return this._patch({\n      uri: 'api/v1/me/prefs',\n      body: updatedPreferences\n    });\n  }\n  /**\n   * @summary Gets the currently-authenticated user's trophies.\n   * @returns {Promise} A TrophyList containing the user's trophies\n   * @example\n   *\n   * r.getMyTrophies().then(console.log)\n   * // => TrophyList { trophies: [\n   * //   Trophy { icon_70: 'https://s3.amazonaws.com/redditstatic/award/verified_email-70.png',\n   * //     description: null,\n   * //     url: null,\n   * //     icon_40: 'https://s3.amazonaws.com/redditstatic/award/verified_email-40.png',\n   * //     award_id: 'o',\n   * //     id: '16fn29',\n   * //     name: 'Verified Email'\n   * //   }\n   * // ] }\n   */\n\n\n  getMyTrophies() {\n    return this._get({\n      uri: 'api/v1/me/trophies'\n    });\n  }\n  /**\n   * @summary Gets the list of the currently-authenticated user's friends.\n   * @returns {Promise} A Promise that resolves with a list of friends\n   * @example\n   *\n   * r.getFriends().then(console.log)\n   * // => [ [ RedditUser { date: 1457927963, name: 'not_an_aardvark', id: 't2_k83md' } ], [] ]\n   */\n\n\n  getFriends() {\n    return this._get({\n      uri: 'prefs/friends'\n    });\n  }\n  /**\n   * @summary Gets the list of people that the currently-authenticated user has blocked.\n   * @returns {Promise} A Promise that resolves with a list of blocked users\n   * @example\n   *\n   * r.getBlockedUsers().then(console.log)\n   * // => [ RedditUser { date: 1457928120, name: 'actually_an_aardvark', id: 't2_q3519' } ]\n   */\n\n\n  getBlockedUsers() {\n    return this._get({\n      uri: 'prefs/blocked'\n    });\n  }\n  /**\n   * @summary Determines whether the currently-authenticated user needs to fill out a captcha in order to submit content.\n   * @returns {Promise} A Promise that resolves with a boolean value\n   * @example\n   *\n   * r.checkCaptchaRequirement().then(console.log)\n   * // => false\n   */\n\n\n  checkCaptchaRequirement() {\n    return this._get({\n      uri: 'api/needs_captcha'\n    });\n  }\n  /**\n   * @summary Gets the identifier (a hex string) for a new captcha image.\n   * @returns {Promise} A Promise that resolves with a string\n   * @example\n   *\n   * r.getNewCaptchaIdentifier().then(console.log)\n   * // => 'o5M18uy4mk0IW4hs0fu2GNPdXb1Dxe9d'\n   */\n\n\n  getNewCaptchaIdentifier() {\n    return this._post({\n      uri: 'api/new_captcha',\n      form: {\n        api_type\n      }\n    }).then(function (res) {\n      return res.json.data.iden;\n    });\n  }\n  /**\n   * @summary Gets an image for a given captcha identifier.\n   * @param {string} identifier The captcha identifier.\n   * @returns {Promise} A string containing raw image data in PNG format\n   * @example\n   *\n   * r.getCaptchaImage('o5M18uy4mk0IW4hs0fu2GNPdXb1Dxe9d').then(console.log)\n   // => (A long, incoherent string representing the image in PNG format)\n   */\n\n\n  getCaptchaImage(identifier) {\n    return this._get({\n      uri: \"captcha/\".concat(identifier)\n    });\n  }\n  /**\n   * @summary Gets an array of categories that items can be saved in. (Requires reddit gold)\n   * @returns {Promise} An array of categories\n   * @example\n   *\n   * r.getSavedCategories().then(console.log)\n   * // => [ { category: 'cute cat pictures' }, { category: 'interesting articles' } ]\n   */\n\n\n  getSavedCategories() {\n    return this._get({\n      uri: 'api/saved_categories'\n    }).get('categories');\n  }\n  /**\n   * @summary Marks a list of submissions as 'visited'.\n   * @desc **Note**: This endpoint only works if the authenticated user is subscribed to reddit gold.\n   * @param {Submission[]} links A list of Submission objects to mark\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * var submissions = [r.getSubmission('4a9u54'), r.getSubmission('4a95nb')]\n   * r.markAsVisited(submissions)\n   * // (the links will now appear purple on reddit)\n   */\n\n\n  markAsVisited(links) {\n    return this._post({\n      uri: 'api/store_visits',\n      links: (0, _lodash.map)(links, 'name').join(',')\n    });\n  }\n\n  _submit(_ref5) {\n    var _this5 = this;\n\n    var captcha_response = _ref5.captcha_response,\n        _ref5$captchaResponse = _ref5.captchaResponse,\n        captchaResponse = _ref5$captchaResponse === void 0 ? captcha_response : _ref5$captchaResponse,\n        captcha_iden = _ref5.captcha_iden,\n        _ref5$captchaIden = _ref5.captchaIden,\n        captchaIden = _ref5$captchaIden === void 0 ? captcha_iden : _ref5$captchaIden,\n        kind = _ref5.kind,\n        _ref5$resubmit = _ref5.resubmit,\n        resubmit = _ref5$resubmit === void 0 ? true : _ref5$resubmit,\n        _ref5$send_replies = _ref5.send_replies,\n        send_replies = _ref5$send_replies === void 0 ? true : _ref5$send_replies,\n        _ref5$sendReplies = _ref5.sendReplies,\n        sendReplies = _ref5$sendReplies === void 0 ? send_replies : _ref5$sendReplies,\n        crosspost_fullname = _ref5.crosspost_fullname,\n        text = _ref5.text,\n        title = _ref5.title,\n        url = _ref5.url,\n        subreddit_name = _ref5.subreddit_name,\n        _ref5$subredditName = _ref5.subredditName,\n        subredditName = _ref5$subredditName === void 0 ? subreddit_name : _ref5$subredditName;\n    return this._post({\n      uri: 'api/submit',\n      form: {\n        api_type,\n        captcha: captchaResponse,\n        iden: captchaIden,\n        sendreplies: sendReplies,\n        sr: subredditName,\n        kind,\n        resubmit,\n        crosspost_fullname,\n        text,\n        title,\n        url\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).then(function (result) {\n      return _this5.getSubmission(result.json.data.id);\n    });\n  }\n  /**\n   * @summary Creates a new selfpost on the given subreddit.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the post should be submitted to\n   * @param {string} options.title The title of the submission\n   * @param {string} [options.text] The selftext of the submission\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * r.submitSelfpost({\n   *   subredditName: 'snoowrap_testing',\n   *   title: 'This is a selfpost',\n   *   text: 'This is the text body of the selfpost'\n   * }).then(console.log)\n   * // => Submission { name: 't3_4abmsz' }\n   * // (new selfpost created on reddit)\n   */\n\n\n  submitSelfpost(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'self'\n    }));\n  }\n  /**\n   * @summary Creates a new link submission on the given subreddit.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the post should be submitted to\n   * @param {string} options.title The title of the submission\n   * @param {string} options.url The url that the link submission should point to\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n   the past, reddit will return an error. This could be used to avoid accidental reposts.\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * r.submitLink({\n   *   subredditName: 'snoowrap_testing',\n   *   title: 'I found a cool website!',\n   *   url: 'https://google.com'\n   * }).then(console.log)\n   * // => Submission { name: 't3_4abnfe' }\n   * // (new linkpost created on reddit)\n   */\n\n\n  submitLink(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'link'\n    }));\n  }\n  /**\n   * @summary Creates a new crosspost submission on the given subreddit\n   * @desc **NOTE**: To create a crosspost, the authenticated account must be subscribed to the subreddit where\n   * the crosspost is being submitted, and that subreddit be configured to allow crossposts.\n   * @param {object} options An object containing details about the submission\n   * @param {string} options.subredditName The name of the subreddit that the crosspost should be submitted to\n   * @param {string} options.title The title of the crosspost\n   * @param {(string|Submission)} options.originalPost A Submission object or a post ID for the original post which\n   is being crossposted\n   * @param {boolean} [options.sendReplies=true] Determines whether inbox replies should be enabled for this submission\n   * @param {boolean} [options.resubmit=true] If this is false and same link has already been submitted to this subreddit in\n   the past, reddit will return an error. This could be used to avoid accidental reposts.\n   * @returns {Promise} The newly-created Submission object\n   * @example\n   *\n   * await r.submitCrosspost({ title: 'I found an interesting post', originalPost: '6vths0', subredditName: 'snoowrap' })\n   */\n\n\n  submitCrosspost(options) {\n    return this._submit(_objectSpread({}, options, {\n      kind: 'crosspost',\n      crosspost_fullname: options.originalPost instanceof snoowrap.objects.Submission ? options.originalPost.name : (0, _helpers.addFullnamePrefix)(options.originalPost, 't3_')\n    }));\n  }\n\n  _getSortedFrontpage(sortType, subredditName) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Handle things properly if only a time parameter is provided but not the subreddit name\n    var opts = options;\n    var subName = subredditName;\n\n    if (typeof subredditName === 'object' && (0, _lodash.isEmpty)((0, _lodash.omitBy)(opts, function (option) {\n      return option === undefined;\n    }))) {\n      /* In this case, \"subredditName\" ends up referring to the second argument, which is not actually a name since the user\n      decided to omit that parameter. */\n      opts = subredditName;\n      subName = undefined;\n    }\n\n    var parsedOptions = (0, _lodash.omit)(_objectSpread({}, opts, {\n      t: opts.time || opts.t\n    }), 'time');\n    return this._getListing({\n      uri: (subName ? \"r/\".concat(subName, \"/\") : '') + sortType,\n      qs: parsedOptions\n    });\n  }\n  /**\n   * @summary Gets a Listing of hot posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getHot().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'pics' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getHot('gifs').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'gifs' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'gifs' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getHot('redditdev', {limit: 1}).then(console.log)\n   * // => Listing [\n   //   Submission { domain: 'self.redditdev', banned_by: null, subreddit: Subreddit { display_name: 'redditdev' }, ...}\n   * // ]\n   */\n\n\n  getHot(subredditName, options) {\n    return this._getSortedFrontpage('hot', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of best posts.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise<Listing>} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getBest().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'pics' }, ... },\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... },\n   * //  ...\n   * // ]\n   *\n   * r.getBest({limit: 1}).then(console.log)\n   * // => Listing [\n   //   Submission { domain: 'self.redditdev', banned_by: null, subreddit: Subreddit { display_name: 'redditdev' }, ...}\n   * // ]\n   */\n\n\n  getBest(options) {\n    return this._getSortedFrontpage('best', undefined, options);\n  }\n  /**\n   * @summary Gets a Listing of new posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getNew().then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.Jokes', banned_by: null, subreddit: Subreddit { display_name: 'Jokes' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  ...\n   * // ]\n   *\n   */\n\n\n  getNew(subredditName, options) {\n    return this._getSortedFrontpage('new', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of new comments.\n   * @param {string} [subredditName] The subreddit to get comments from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved comments\n   * @example\n   *\n   * r.getNewComments().then(console.log)\n   * // => Listing [\n   * //  Comment { link_title: 'What amazing book should be made into a movie, but hasn\\'t been yet?', ... }\n   * //  Comment { link_title: 'How far back in time could you go and still understand English?', ... }\n   * // ]\n   */\n\n\n  getNewComments(subredditName, options) {\n    return this._getSortedFrontpage('comments', subredditName, options);\n  }\n  /**\n   *  @summary Get list of content by IDs. Returns a listing of the requested content.\n   *  @param {Array<string|Submission|Comment>} ids An array of content IDs. Can include the id itself, or a Submission or Comment object.\n  can get a post and a comment   *  @returns {Promise<Listing<Submission|Comment>>} A listing of content requested, can be any class fetchable by API. e.g. Comment, Submission\n   *  @example\n   *\n   * r.getContentByIds(['t3_9l9vof','t3_9la341']).then(console.log);\n   * // => Listing [\n   * //  Submission { approved_at_utc: null, ... }\n   * //  Submission { approved_at_utc: null, ... }\n   * // ]\n   *\n   * r.getContentByIds([r.getSubmission('9l9vof'), r.getSubmission('9la341')]).then(console.log);\n   * // => Listing [\n   * //  Submission { approved_at_utc: null, ... }\n   * //  Submission { approved_at_utc: null, ... }\n   * // ]\n  */\n\n\n  getContentByIds(ids) {\n    if (!Array.isArray(ids)) {\n      throw new TypeError('Invalid argument: Argument needs to be an array.');\n    }\n\n    var prefixedIds = ids.map(function (id) {\n      if (id instanceof snoowrap.objects.Submission || id instanceof snoowrap.objects.Comment) {\n        return id.name;\n      } else if (typeof id === 'string') {\n        if (!/t(1|3)_/g.test(ids)) {\n          throw new TypeError('Invalid argument: Ids need to include Submission or Comment prefix, e.g. t1_, t3_.');\n        }\n\n        return id;\n      }\n\n      throw new TypeError('Id must be either a string, Submission, or Comment.');\n    });\n    return this._get({\n      uri: '/api/info',\n      method: 'get',\n      qs: {\n        id: prefixedIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Gets a single random Submission.\n   * @desc **Note**: This function will not work when snoowrap is running in a browser, because the reddit server sends a\n   redirect which cannot be followed by a CORS request.\n   * @param {string} [subredditName] The subreddit to get the random submission. If not provided, the post is fetched from\n   the front page of reddit.\n   * @returns {Promise} The retrieved Submission object\n   * @example\n   *\n   * r.getRandomSubmission('aww').then(console.log)\n   * // => Submission { domain: 'i.imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'aww' }, ... }\n   */\n\n\n  getRandomSubmission(subredditName) {\n    return this._get({\n      uri: \"\".concat(subredditName ? \"r/\".concat(subredditName, \"/\") : '', \"random\")\n    });\n  }\n  /**\n   * @summary Gets a Listing of top posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n   `hour, day, week, month, year, all`\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getTop({time: 'all', limit: 2}).then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'imgur.com', banned_by: null, subreddit: Subreddit { display_name: 'funny' }, ... }\n   * // ]\n   *\n   * r.getTop('AskReddit').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  Submission { domain: 'self.AskReddit', banned_by: null, subreddit: Subreddit { display_name: 'AskReddit' }, ... },\n   * //  ...\n   * // ]\n   */\n\n\n  getTop(subredditName, options) {\n    return this._getSortedFrontpage('top', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of controversial posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. Should be one of\n   `hour, day, week, month, year, all`\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getControversial('technology').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'thenextweb.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... },\n   * //  Submission { domain: 'pcmag.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... }\n   * // ]\n   */\n\n\n  getControversial(subredditName, options) {\n    return this._getSortedFrontpage('controversial', subredditName, options);\n  }\n  /**\n   * @summary Gets a Listing of controversial posts.\n   * @param {string} [subredditName] The subreddit to get posts from. If not provided, posts are fetched from\n   the front page of reddit.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing the retrieved submissions\n   * @example\n   *\n   * r.getRising('technology').then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'thenextweb.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... },\n   * //  Submission { domain: 'pcmag.com', banned_by: null, subreddit: Subreddit { display_name: 'technology' }, ... }\n   * // ]\n   */\n\n\n  getRising(subredditName, options) {\n    return this._getSortedFrontpage('rising', subredditName, options);\n  }\n  /**\n   * @summary Gets the authenticated user's unread messages.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing containing unread items in the user's inbox\n   * @example\n   *\n   * r.getUnreadMessages().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'hi!', was_comment: false, first_message: null, ... },\n   * //  Comment { body: 'this is a reply', link_title: 'Yay, a selfpost!', was_comment: true, ... }\n   * // ]\n   */\n\n\n  getUnreadMessages() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/unread',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets the items in the authenticated user's inbox.\n   * @param {object} [options={}] Filter options. Can also contain options for the resulting Listing.\n   * @param {string} [options.filter] A filter for the inbox items. If provided, it should be one of `unread`, (unread\n   items), `messages` (i.e. PMs), `comments` (comment replies), `selfreply` (selfpost replies), or `mentions` (username\n   mentions).\n   * @returns {Promise} A Listing containing items in the user's inbox\n   * @example\n   *\n   * r.getInbox().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'hi!', was_comment: false, first_message: null, ... },\n   * //  Comment { body: 'this is a reply', link_title: 'Yay, a selfpost!', was_comment: true, ... }\n   * // ]\n   */\n\n\n  getInbox() {\n    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        filter = _ref6.filter,\n        options = _objectWithoutProperties(_ref6, [\"filter\"]);\n\n    return this._getListing({\n      uri: \"message/\".concat(filter || 'inbox'),\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets the authenticated user's modmail.\n   * @param {object} [options={}] Options for the resulting Listing\n   * @returns {Promise} A Listing of the user's modmail\n   * @example\n   *\n   * r.getModmail({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: '/u/not_an_aardvark has accepted an invitation to become moderator ... ', ... },\n   * //  PrivateMessage { body: '/u/not_an_aardvark has been invited by /u/actually_an_aardvark to ...', ... }\n   * // ]\n   */\n\n\n  getModmail() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/moderator',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of ModmailConversations from the authenticated user's subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise<Listing<ModmailConversation>>} A Listing containing Subreddits\n   * @example\n   *\n   * r.getNewModmailConversations({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... },\n   * //  ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... }\n   * // ]\n   */\n\n\n  getNewModmailConversations() {\n    var _this6 = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'api/mod/conversations',\n      qs: options,\n      _name: 'ModmailConversation',\n      _transform: function (response) {\n        response.after = null;\n        response.before = null;\n        response.children = [];\n\n        for (var conversation of response.conversationIds) {\n          response.conversations[conversation].participant = _this6._newObject('ModmailConversationAuthor', _objectSpread({}, response.conversations[conversation].participant));\n\n          var conversationObjects = objects.ModmailConversation._getConversationObjects(response.conversations[conversation], response);\n\n          var data = _objectSpread({}, conversationObjects, {}, response.conversations[conversation]);\n\n          response.children.push(_this6._newObject('ModmailConversation', data));\n        }\n\n        return _this6._newObject('Listing', response);\n      }\n    });\n  }\n  /**\n   * @summary Create a new modmail discussion between moderators\n   * @param {object} options\n   * @param {string} options.body Body of the discussion\n   * @param {string} options.subject Title or subject\n   * @param {string} options.srName Subreddit name without fullname\n   * @returns {Promise<ModmailConversation>} the created ModmailConversation\n   * @example\n   *\n   * r.createModeratorDiscussion({\n   *   body: 'test body',\n   *   subject: 'test subject',\n   *   srName: 'AskReddit'\n   * }).then(console.log)\n   * // ModmailConversation { messages: [...], objIds: [...], subject: 'test subject', ... }\n   */\n\n\n  createModmailDiscussion(_ref7) {\n    var _this7 = this;\n\n    var body = _ref7.body,\n        subject = _ref7.subject,\n        srName = _ref7.srName;\n    var parsedFromSr = srName.replace(/^\\/?r\\//, ''); // Convert '/r/subreddit_name' to 'subreddit_name'\n    // _newObject ignores most of the response, no practical way to parse the returned content yet\n\n    return this._post({\n      uri: 'api/mod/conversations',\n      form: {\n        body,\n        subject,\n        srName: parsedFromSr\n      }\n    }).then(function (res) {\n      return _this7._newObject('ModmailConversation', {\n        id: res.conversation.id\n      });\n    });\n  }\n  /**\n   * @summary Get a ModmailConversation by its id\n   * @param {string} id of the ModmailConversation\n   * @returns {Promise<ModmailConversation>} the requested ModmailConversation\n   * @example\n   *\n   * r.getNewModmailConversation('75hxt').then(console.log)\n   * // ModmailConversation { messages: [...], objIds: [...], ... }\n   */\n\n\n  getNewModmailConversation(id) {\n    return this._newObject('ModmailConversation', {\n      id\n    });\n  }\n  /**\n   * @summary Marks all conversations in array as read.\n   * @param {ModmailConversation[]} conversations to mark as read\n   * @example\n   *\n   * r.markNewModmailConversationsAsRead(['pics', 'sweden'])\n   */\n\n\n  markNewModmailConversationsAsRead(conversations) {\n    var conversationIds = conversations.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, '');\n    });\n    return this._post({\n      uri: 'api/mod/conversations/read',\n      form: {\n        conversationIds: conversationIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all conversations in array as unread.\n   * @param {ModmailConversation[]} conversations to mark as unread\n   * @example\n   *\n   * r.markNewModmailConversationsAsUnread(['pics', 'sweden'])\n   */\n\n\n  markNewModmailConversationsAsUnread(conversations) {\n    var conversationIds = conversations.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, '');\n    });\n    return this._post({\n      uri: 'api/mod/conversations/unread',\n      form: {\n        conversationIds: conversationIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Gets all moderated subreddits that have new Modmail activated\n   * @returns {Promise<Listing<Subreddit>>} a Listing of ModmailConversations marked as read\n   * @example\n   *\n   * r.getNewModmailSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit { display_name: 'tipofmytongue', ... },\n   * //  Subreddit { display_name: 'EarthPorn', ... },\n   * // ]\n   */\n\n\n  getNewModmailSubreddits() {\n    var _this8 = this;\n\n    return this._get({\n      uri: 'api/mod/conversations/subreddits'\n    }).then(function (response) {\n      return Object.values(response.subreddits).map(function (s) {\n        return _this8._newObject('Subreddit', s);\n      });\n    });\n  }\n  /**\n   * @summary Represents the unread count in a {@link ModmailConversation}. Each of these properties\n   * correspond to the amount of unread conversations of that type.\n   * @typedef {Object} UnreadCount\n   * @property {number} highlighted\n   * @property {number} notifications\n   * @property {number} archived\n   * @property {number} new\n   * @property {number} inprogress\n   * @property {number} mod\n   */\n\n  /**\n   * @summary Retrieves an object of unread Modmail conversations for each state.\n   * @returns {UnreadCount} unreadCount\n   * @example\n   *\n   * r.getUnreadNewModmailConversationsCount().then(console.log)\n   * // => {\n   * //  highlighted: 1,\n   * //  notifications: 0,\n   * //  archived: 0,\n   * //  new: 2,\n   * //  inprogress: 5,\n   * //  mod: 1,\n   * // }\n   */\n\n\n  getUnreadNewModmailConversationsCount() {\n    return this._get({\n      uri: 'api/mod/conversations/unread/count'\n    });\n  }\n  /**\n   * @summary Mark Modmail conversations as read given the subreddit(s) and state.\n   * @param {Subreddit[]|String[]} subreddits\n   * @param {('new'|'inprogress'|'mod'|'notifications'|'archived'|'highlighted'|'all')} state selected state to mark as read\n   * @returns {Promise<Listing<ModmailConversation>>} a Listing of ModmailConversations marked as read\n   * @example\n   *\n   * r.bulkReadNewModmail(['AskReddit'], 'all').then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { id: '75hxt' },\n   * //  ModmailConversation { id: '75hxg' }\n   * // ]\n   *\n   * r.bulkReadNewModmail([r.getSubreddit('AskReddit')], 'all').then(console.log)\n   * // => Listing [\n   * //  ModmailConversation { id: '75hxt' },\n   * //  ModmailConversation { id: '75hxg' }\n   * // ]\n   */\n\n\n  bulkReadNewModmail(subreddits, state) {\n    var _this9 = this;\n\n    var subredditNames = subreddits.map(function (s) {\n      return typeof s === 'string' ? s.replace(/^\\/?r\\//, '') : s.display_name;\n    });\n    return this._post({\n      uri: 'api/mod/conversations/bulk/read',\n      form: {\n        entity: subredditNames.join(','),\n        state\n      }\n    }).then(function (res) {\n      return _this9._newObject('Listing', {\n        after: null,\n        before: null,\n        children: res.conversation_ids.map(function (id) {\n          return _this9._newObject('ModmailConversation', {\n            id\n          });\n        })\n      });\n    });\n  }\n  /**\n   * @summary Gets the user's sent messages.\n   * @param {object} [options={}] options for the resulting Listing\n   * @returns {Promise} A Listing of the user's sent messages\n   * @example\n   *\n   * r.getSentMessages().then(console.log)\n   * // => Listing [\n   * //  PrivateMessage { body: 'you have been added as an approved submitter to ...', ... },\n   * //  PrivateMessage { body: 'you have been banned from posting to ...' ... }\n   * // ]\n   */\n\n\n  getSentMessages() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this._getListing({\n      uri: 'message/sent',\n      qs: options\n    });\n  }\n  /**\n   * @summary Marks all of the given messages as read.\n   * @param {PrivateMessage[]|String[]} messages An Array of PrivateMessage or Comment objects. Can also contain strings\n   representing message or comment IDs. If strings are provided, they are assumed to represent PrivateMessages unless a fullname\n   prefix such as `t1_` is specified.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.markMessagesAsRead(['51shsd', '51shxv'])\n   *\n   * // To reference a comment by ID, be sure to use the `t1_` prefix, otherwise snoowrap will be unable to distinguish the\n   * // comment ID from a PrivateMessage ID.\n   * r.markMessagesAsRead(['t5_51shsd', 't1_d3zhb5k'])\n   *\n   * // Alternatively, just pass in a comment object directly.\n   * r.markMessagesAsRead([r.getMessage('51shsd'), r.getComment('d3zhb5k')])\n   */\n\n\n  markMessagesAsRead(messages) {\n    var messageIds = messages.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, 't4_');\n    });\n    return this._post({\n      uri: 'api/read_message',\n      form: {\n        id: messageIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all of the given messages as unread.\n   * @param {PrivateMessage[]|String[]} messages An Array of PrivateMessage or Comment objects. Can also contain strings\n   representing message IDs. If strings are provided, they are assumed to represent PrivateMessages unless a fullname prefix such\n   as `t1_` is included.\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.markMessagesAsUnread(['51shsd', '51shxv'])\n   *\n   * // To reference a comment by ID, be sure to use the `t1_` prefix, otherwise snoowrap will be unable to distinguish the\n   * // comment ID from a PrivateMessage ID.\n   * r.markMessagesAsUnread(['t5_51shsd', 't1_d3zhb5k'])\n   *\n   * // Alternatively, just pass in a comment object directly.\n   * r.markMessagesAsRead([r.getMessage('51shsd'), r.getComment('d3zhb5k')])\n   */\n\n\n  markMessagesAsUnread(messages) {\n    var messageIds = messages.map(function (message) {\n      return (0, _helpers.addFullnamePrefix)(message, 't4_');\n    });\n    return this._post({\n      uri: 'api/unread_message',\n      form: {\n        id: messageIds.join(',')\n      }\n    });\n  }\n  /**\n   * @summary Marks all of the user's messages as read.\n   * @desc **Note:** The reddit.com site imposes a ratelimit of approximately 1 request every 10 minutes on this endpoint.\n   Further requests will cause the API to return a 429 error.\n   * @returns {Promise} A Promise that resolves when the request is complete\n   * @example\n   *\n   * r.readAllMessages().then(function () {\n   *   r.getUnreadMessages().then(console.log)\n   * })\n   * // => Listing []\n   * // (messages marked as 'read' on reddit)\n   */\n\n\n  readAllMessages() {\n    return this._post({\n      uri: 'api/read_all_messages'\n    });\n  }\n  /**\n   * @summary Composes a new private message.\n   * @param {object} options\n   * @param {RedditUser|Subreddit|string} options.to The recipient of the message.\n   * @param {string} options.subject The message subject (100 characters max)\n   * @param {string} options.text The body of the message, in raw markdown text\n   * @param {Subreddit|string} [options.fromSubreddit] If provided, the message is sent as a modmail from the specified\n   subreddit.\n   * @param {string} [options.captchaIden] A captcha identifier. This is only necessary if the authenticated account\n   requires a captcha to submit posts and comments.\n   * @param {string} [options.captchaResponse] The response to the captcha with the given identifier\n   * @returns {Promise} A Promise that fulfills when the request is complete\n   * @example\n   *\n   * r.composeMessage({\n   *   to: 'actually_an_aardvark',\n   *   subject: \"Hi, how's it going?\",\n   *   text: 'Long time no see'\n   * })\n   * // (message created on reddit)\n   */\n\n\n  composeMessage(_ref8) {\n    var captcha = _ref8.captcha,\n        from_subreddit = _ref8.from_subreddit,\n        _ref8$fromSubreddit = _ref8.fromSubreddit,\n        fromSubreddit = _ref8$fromSubreddit === void 0 ? from_subreddit : _ref8$fromSubreddit,\n        captcha_iden = _ref8.captcha_iden,\n        _ref8$captchaIden = _ref8.captchaIden,\n        captchaIden = _ref8$captchaIden === void 0 ? captcha_iden : _ref8$captchaIden,\n        subject = _ref8.subject,\n        text = _ref8.text,\n        to = _ref8.to;\n    var parsedTo = to;\n    var parsedFromSr = fromSubreddit;\n\n    if (to instanceof snoowrap.objects.RedditUser) {\n      parsedTo = to.name;\n    } else if (to instanceof snoowrap.objects.Subreddit) {\n      parsedTo = \"/r/\".concat(to.display_name);\n    }\n\n    if (fromSubreddit instanceof snoowrap.objects.Subreddit) {\n      parsedFromSr = fromSubreddit.display_name;\n    } else if (typeof fromSubreddit === 'string') {\n      parsedFromSr = fromSubreddit.replace(/^\\/?r\\//, ''); // Convert '/r/subreddit_name' to 'subreddit_name'\n    }\n\n    return this._post({\n      uri: 'api/compose',\n      form: {\n        api_type,\n        captcha,\n        iden: captchaIden,\n        from_sr: parsedFromSr,\n        subject,\n        text,\n        to: parsedTo\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).return({});\n  }\n  /**\n   * @summary Gets a list of all oauth scopes supported by the reddit API.\n   * @desc **Note**: This lists every single oauth scope. To get the scope of this requester, use the `scope` property instead.\n   * @returns {Promise} An object containing oauth scopes.\n   * @example\n   *\n   * r.getOauthScopeList().then(console.log)\n   * // => {\n   * //  creddits: {\n   * //    description: 'Spend my reddit gold creddits on giving gold to other users.',\n   * //    id: 'creddits',\n   * //    name: 'Spend reddit gold creddits'\n   * //  },\n   * //  modcontributors: {\n   * //    description: 'Add/remove users to approved submitter lists and ban/unban or mute/unmute users from ...',\n   * //    id: 'modcontributors',\n   * //    name: 'Approve submitters and ban users'\n   * //  },\n   * //  ...\n   * // }\n   */\n\n\n  getOauthScopeList() {\n    return this._get({\n      uri: 'api/v1/scopes'\n    });\n  }\n  /**\n   * @summary Conducts a search of reddit submissions.\n   * @param {object} options Search options. Can also contain options for the resulting Listing.\n   * @param {string} options.query The search query\n   * @param {string} [options.time] Describes the timespan that posts should be retrieved from. One of\n   `hour, day, week, month, year, all`\n   * @param {Subreddit|string} [options.subreddit] The subreddit to conduct the search on.\n   * @param {boolean} [options.restrictSr=true] Restricts search results to the given subreddit\n   * @param {string} [options.sort] Determines how the results should be sorted. One of `relevance, hot, top, new, comments`\n   * @param {string} [options.syntax='plain'] Specifies a syntax for the search. One of `cloudsearch, lucene, plain`\n   * @returns {Promise} A Listing containing the search results.\n   * @example\n   *\n   * r.search({\n   *   query: 'Cute kittens',\n   *   subreddit: 'aww',\n   *   sort: 'top'\n   * }).then(console.log)\n   * // => Listing [\n   * //  Submission { domain: 'i.imgur.com', banned_by: null, ... },\n   * //  Submission { domain: 'imgur.com', banned_by: null, ... },\n   * //  ...\n   * // ]\n   */\n\n\n  search(options) {\n    if (options.subreddit instanceof snoowrap.objects.Subreddit) {\n      options.subreddit = options.subreddit.display_name;\n    }\n\n    (0, _lodash.defaults)(options, {\n      restrictSr: true,\n      syntax: 'plain'\n    });\n    var parsedQuery = (0, _lodash.omit)(_objectSpread({}, options, {\n      t: options.time,\n      q: options.query,\n      restrict_sr: options.restrictSr\n    }), ['time', 'query']);\n    return this._getListing({\n      uri: \"\".concat(options.subreddit ? \"r/\".concat(options.subreddit, \"/\") : '', \"search\"),\n      qs: parsedQuery\n    });\n  }\n  /**\n   * @summary Searches for subreddits given a query.\n   * @param {object} options\n   * @param {string} options.query A search query (50 characters max)\n   * @param {boolean} [options.exact=false] Determines whether the results shouldbe limited to exact matches.\n   * @param {boolean} [options.includeNsfw=true] Determines whether the results should include NSFW subreddits.\n   * @returns {Promise} An Array containing subreddit names\n   * @example\n   *\n   * r.searchSubredditNames({query: 'programming'}).then(console.log)\n   * // => [\n   * //  'programming',\n   * //  'programmingcirclejerk',\n   * //  'programminghorror',\n   * //  ...\n   * // ]\n   */\n\n\n  searchSubredditNames(_ref9) {\n    var _ref9$exact = _ref9.exact,\n        exact = _ref9$exact === void 0 ? false : _ref9$exact,\n        _ref9$include_nsfw = _ref9.include_nsfw,\n        include_nsfw = _ref9$include_nsfw === void 0 ? true : _ref9$include_nsfw,\n        _ref9$includeNsfw = _ref9.includeNsfw,\n        includeNsfw = _ref9$includeNsfw === void 0 ? include_nsfw : _ref9$includeNsfw,\n        query = _ref9.query;\n    return this._post({\n      uri: 'api/search_reddit_names',\n      qs: {\n        exact,\n        include_over_18: includeNsfw,\n        query\n      }\n    }).get('names');\n  }\n\n  _createOrEditSubreddit(_ref10) {\n    var _ref10$allow_images = _ref10.allow_images,\n        allow_images = _ref10$allow_images === void 0 ? true : _ref10$allow_images,\n        _ref10$allow_top = _ref10.allow_top,\n        allow_top = _ref10$allow_top === void 0 ? true : _ref10$allow_top,\n        captcha = _ref10.captcha,\n        captcha_iden = _ref10.captcha_iden,\n        _ref10$collapse_delet = _ref10.collapse_deleted_comments,\n        collapse_deleted_comments = _ref10$collapse_delet === void 0 ? false : _ref10$collapse_delet,\n        _ref10$comment_score_ = _ref10.comment_score_hide_mins,\n        comment_score_hide_mins = _ref10$comment_score_ === void 0 ? 0 : _ref10$comment_score_,\n        description = _ref10.description,\n        _ref10$exclude_banned = _ref10.exclude_banned_modqueue,\n        exclude_banned_modqueue = _ref10$exclude_banned === void 0 ? false : _ref10$exclude_banned,\n        header_title = _ref10['header-title'],\n        _ref10$hide_ads = _ref10.hide_ads,\n        hide_ads = _ref10$hide_ads === void 0 ? false : _ref10$hide_ads,\n        _ref10$lang = _ref10.lang,\n        lang = _ref10$lang === void 0 ? 'en' : _ref10$lang,\n        _ref10$link_type = _ref10.link_type,\n        link_type = _ref10$link_type === void 0 ? 'any' : _ref10$link_type,\n        name = _ref10.name,\n        _ref10$over_ = _ref10.over_18,\n        over_18 = _ref10$over_ === void 0 ? false : _ref10$over_,\n        public_description = _ref10.public_description,\n        _ref10$public_traffic = _ref10.public_traffic,\n        public_traffic = _ref10$public_traffic === void 0 ? false : _ref10$public_traffic,\n        _ref10$show_media = _ref10.show_media,\n        show_media = _ref10$show_media === void 0 ? false : _ref10$show_media,\n        _ref10$show_media_pre = _ref10.show_media_preview,\n        show_media_preview = _ref10$show_media_pre === void 0 ? true : _ref10$show_media_pre,\n        _ref10$spam_comments = _ref10.spam_comments,\n        spam_comments = _ref10$spam_comments === void 0 ? 'high' : _ref10$spam_comments,\n        _ref10$spam_links = _ref10.spam_links,\n        spam_links = _ref10$spam_links === void 0 ? 'high' : _ref10$spam_links,\n        _ref10$spam_selfposts = _ref10.spam_selfposts,\n        spam_selfposts = _ref10$spam_selfposts === void 0 ? 'high' : _ref10$spam_selfposts,\n        _ref10$spoilers_enabl = _ref10.spoilers_enabled,\n        spoilers_enabled = _ref10$spoilers_enabl === void 0 ? false : _ref10$spoilers_enabl,\n        sr = _ref10.sr,\n        _ref10$submit_link_la = _ref10.submit_link_label,\n        submit_link_label = _ref10$submit_link_la === void 0 ? '' : _ref10$submit_link_la,\n        _ref10$submit_text_la = _ref10.submit_text_label,\n        submit_text_label = _ref10$submit_text_la === void 0 ? '' : _ref10$submit_text_la,\n        _ref10$submit_text = _ref10.submit_text,\n        submit_text = _ref10$submit_text === void 0 ? '' : _ref10$submit_text,\n        _ref10$suggested_comm = _ref10.suggested_comment_sort,\n        suggested_comment_sort = _ref10$suggested_comm === void 0 ? 'confidence' : _ref10$suggested_comm,\n        title = _ref10.title,\n        _ref10$type = _ref10.type,\n        type = _ref10$type === void 0 ? 'public' : _ref10$type,\n        wiki_edit_age = _ref10.wiki_edit_age,\n        wiki_edit_karma = _ref10.wiki_edit_karma,\n        _ref10$wikimode = _ref10.wikimode,\n        wikimode = _ref10$wikimode === void 0 ? 'modonly' : _ref10$wikimode;\n    return this._post({\n      uri: 'api/site_admin',\n      form: {\n        allow_images,\n        allow_top,\n        api_type,\n        captcha,\n        collapse_deleted_comments,\n        comment_score_hide_mins,\n        description,\n        exclude_banned_modqueue,\n        'header-title': header_title,\n        hide_ads,\n        iden: captcha_iden,\n        lang,\n        link_type,\n        name,\n        over_18,\n        public_description,\n        public_traffic,\n        show_media,\n        show_media_preview,\n        spam_comments,\n        spam_links,\n        spam_selfposts,\n        spoilers_enabled,\n        sr,\n        submit_link_label,\n        submit_text,\n        submit_text_label,\n        suggested_comment_sort,\n        title,\n        type,\n        wiki_edit_age,\n        wiki_edit_karma,\n        wikimode\n      }\n    }).then((0, _helpers.handleJsonErrors)(this.getSubreddit(name || sr)));\n  }\n  /**\n   * @summary Creates a new subreddit.\n   * @param {object} options\n   * @param {string} options.name The name of the new subreddit\n   * @param {string} options.title The text that should appear in the header of the subreddit\n   * @param {string} options.public_description The text that appears with this subreddit on the search page, or on the\n   blocked-access page if this subreddit is private. (500 characters max)\n   * @param {string} options.description The sidebar text for the subreddit. (5120 characters max)\n   * @param {string} [options.submit_text=''] The text to show below the submission page (1024 characters max)\n   * @param {boolean} [options.hide_ads=false] Determines whether ads should be hidden on this subreddit. (This is only\n   allowed for gold-only subreddits.)\n   * @param {string} [options.lang='en'] The language of the subreddit (represented as an IETF language tag)\n   * @param {string} [options.type='public'] Determines who should be able to access the subreddit. This should be one of\n   `public, private, restricted, gold_restricted, gold_only, archived, employees_only`.\n   * @param {string} [options.link_type='any'] Determines what types of submissions are allowed on the subreddit. This should\n   be one of `any, link, self`.\n   * @param {string} [options.submit_link_label=undefined] Custom text to display on the button that submits a link. If\n   this is omitted, the default text will be displayed.\n   * @param {string} [options.submit_text_label=undefined] Custom text to display on the button that submits a selfpost. If\n   this is omitted, the default text will be displayed.\n   * @param {string} [options.wikimode='modonly'] Determines who can edit wiki pages on the subreddit. This should be one of\n   `modonly, anyone, disabled`.\n   * @param {number} [options.wiki_edit_karma=0] The minimum amount of subreddit karma needed for someone to edit this\n   subreddit's wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n   * @param {number} [options.wiki_edit_age=0] The minimum account age (in days) needed for someone to edit this subreddit's\n   wiki. (This is only relevant if `options.wikimode` is set to `anyone`.)\n   * @param {string} [options.spam_links='high'] The spam filter strength for links on this subreddit. This should be one of\n   `low, high, all`.\n   * @param {string} [options.spam_selfposts='high'] The spam filter strength for selfposts on this subreddit. This should be\n   one of `low, high, all`.\n   * @param {string} [options.spam_comments='high'] The spam filter strength for comments on this subreddit. This should be one\n   of `low, high, all`.\n   * @param {boolean} [options.over_18=false] Determines whether this subreddit should be classified as NSFW\n   * @param {boolean} [options.allow_top=true] Determines whether the new subreddit should be able to appear in /r/all and\n   trending subreddits\n   * @param {boolean} [options.show_media=false] Determines whether image thumbnails should be enabled on this subreddit\n   * @param {boolean} [options.show_media_preview=true] Determines whether media previews should be expanded by default on this\n   subreddit\n   * @param {boolean} [options.allow_images=true] Determines whether image uploads and links to image hosting sites should be\n   enabled on this subreddit\n   * @param {boolean} [options.exclude_banned_modqueue=false] Determines whether posts by site-wide banned users should be\n   excluded from the modqueue.\n   * @param {boolean} [options.public_traffic=false] Determines whether the /about/traffic page for this subreddit should be\n   viewable by anyone.\n   * @param {boolean} [options.collapse_deleted_comments=false] Determines whether deleted and removed comments should be\n   collapsed by default\n   * @param {string} [options.suggested_comment_sort=undefined] The suggested comment sort for the subreddit. This should be\n   one of `confidence, top, new, controversial, old, random, qa`.If left blank, there will be no suggested sort,\n   which means that users will see the sort method that is set in their own preferences (usually `confidence`.)\n   * @param {boolean} [options.spoilers_enabled=false] Determines whether users can mark their posts as spoilers\n   * @returns {Promise} A Promise for the newly-created subreddit object.\n   * @example\n   *\n   * r.createSubreddit({\n   *   name: 'snoowrap_testing2',\n   *   title: 'snoowrap testing: the sequel',\n   *   public_description: 'thanks for reading the snoowrap docs!',\n   *   description: 'This text will go on the sidebar',\n   *   type: 'private'\n   * }).then(console.log)\n   * // => Subreddit { display_name: 'snoowrap_testing2' }\n   * // (/r/snoowrap_testing2 created on reddit)\n   */\n\n\n  createSubreddit(options) {\n    return this._createOrEditSubreddit(options);\n  }\n  /**\n   * @summary Searches subreddits by topic.\n   * @param {object} options\n   * @param {string} options.query The search query. (50 characters max)\n   * @returns {Promise} An Array of subreddit objects corresponding to the search results\n   * @deprecated Reddit no longer provides the corresponding API endpoint.\n   * @example\n   *\n   * r.searchSubredditTopics({query: 'movies'}).then(console.log)\n   * // => [\n   * //  Subreddit { display_name: 'tipofmytongue' },\n   * //  Subreddit { display_name: 'remove' },\n   * //  Subreddit { display_name: 'horror' },\n   * //  ...\n   * // ]\n   */\n\n\n  searchSubredditTopics(_ref11) {\n    var _this10 = this;\n\n    var query = _ref11.query;\n    return this._get({\n      uri: 'api/subreddits_by_topic',\n      qs: {\n        query\n      }\n    }).map(function (result) {\n      return _this10.getSubreddit(result.name);\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits that the currently-authenticated user is subscribed to.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getSubscriptions({limit: 2}).then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'gadgets',\n   * //    title: 'reddit gadget guide',\n   * //    ...\n   * //  },\n   * //  Subreddit {\n   * //    display_name: 'sports',\n   * //    title: 'the sportspage of the Internet',\n   * //    ...\n   * //  }\n   * // ]\n   */\n\n\n  getSubscriptions(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/subscriber',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits in which the currently-authenticated user is an approved submitter.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getContributorSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'snoowrap_testing',\n   * //    title: 'snoowrap',\n   * //    ...\n   * //  }\n   * // ]\n   *\n   */\n\n\n  getContributorSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/contributor',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits in which the currently-authenticated user is a moderator.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getModeratedSubreddits().then(console.log)\n   * // => Listing [\n   * //  Subreddit {\n   * //    display_name: 'snoowrap_testing',\n   * //    title: 'snoowrap',\n   * //    ...\n   * //  }\n   * // ]\n   */\n\n\n  getModeratedSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/mine/moderator',\n      qs: options\n    });\n  }\n  /**\n   * @summary Searches subreddits by title and description.\n   * @param {object} options Options for the search. May also contain Listing parameters.\n   * @param {string} options.query The search query\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.searchSubreddits({query: 'cookies'}).then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  searchSubreddits(options) {\n    options.q = options.query;\n    return this._getListing({\n      uri: 'subreddits/search',\n      qs: (0, _lodash.omit)(options, 'query')\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits, arranged by popularity.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getPopularSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getPopularSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/popular',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of subreddits, arranged by age.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getNewSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getNewSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/new',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of gold-exclusive subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getGoldSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getGoldSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/gold',\n      qs: options\n    });\n  }\n  /**\n   * @summary Gets a list of default subreddits.\n   * @param {object} [options] Options for the resulting Listing\n   * @returns {Promise} A Listing containing Subreddits\n   * @example\n   *\n   * r.getDefaultSubreddits().then(console.log)\n   * // => Listing [ Subreddit { ... }, Subreddit { ... }, ...]\n   */\n\n\n  getDefaultSubreddits(options) {\n    return this._getListing({\n      uri: 'subreddits/default',\n      qs: options\n    });\n  }\n  /**\n   * @summary Checks whether a given username is available for registration\n   * @desc **Note:** This function will not work when snoowrap is running in a browser, due to an issue with reddit's CORS\n   settings.\n   * @param {string} name The username in question\n   * @returns {Promise} A Promise that fulfills with a Boolean (`true` or `false`)\n   * @example\n   *\n   * r.checkUsernameAvailability('not_an_aardvark').then(console.log)\n   * // => false\n   * r.checkUsernameAvailability('eqwZAr9qunx7IHqzWVeF').then(console.log)\n   * // => true\n   */\n\n\n  checkUsernameAvailability(name) {\n    // The oauth endpoint listed in reddit's documentation doesn't actually work, so just send an unauthenticated request.\n    return this.unauthenticatedRequest({\n      uri: 'api/username_available.json',\n      qs: {\n        user: name\n      }\n    });\n  }\n  /**\n   * @summary Creates a new LiveThread.\n   * @param {object} options\n   * @param {string} options.title The title of the livethread (100 characters max)\n   * @param {string} [options.description] A descriptions of the thread. 120 characters max\n   * @param {string} [options.resources] Information and useful links related to the thread. 120 characters max\n   * @param {boolean} [options.nsfw=false] Determines whether the thread is Not Safe For Work\n   * @returns {Promise} A Promise that fulfills with the new LiveThread when the request is complete\n   * @example\n   *\n   * r.createLivethread({title: 'My livethread'}).then(console.log)\n   * // => LiveThread { id: 'wpimncm1f01j' }\n   */\n\n\n  createLivethread(_ref12) {\n    var _this11 = this;\n\n    var title = _ref12.title,\n        description = _ref12.description,\n        resources = _ref12.resources,\n        _ref12$nsfw = _ref12.nsfw,\n        nsfw = _ref12$nsfw === void 0 ? false : _ref12$nsfw;\n    return this._post({\n      uri: 'api/live/create',\n      form: {\n        api_type,\n        description,\n        nsfw,\n        resources,\n        title\n      }\n    }).tap((0, _helpers.handleJsonErrors)(this)).then(function (result) {\n      return _this11.getLivethread(result.json.data.id);\n    });\n  }\n  /**\n   * @summary Gets the \"happening now\" LiveThread, if it exists\n   * @desc This is the LiveThread that is occasionally linked at the top of reddit.com, relating to current events.\n   * @returns {Promise} A Promise that fulfills with the \"happening now\" LiveThread if it exists, or rejects with a 404 error\n   otherwise.\n   * @example r.getCurrentEventsLivethread().then(thread => thread.stream.on('update', console.log))\n   */\n\n\n  getStickiedLivethread() {\n    return this._get({\n      uri: 'api/live/happening_now'\n    });\n  }\n  /**\n   * @summary Gets the user's own multireddits.\n   * @returns {Promise} A Promise for an Array containing the requester's MultiReddits.\n   * @example\n   *\n   * r.getMyMultireddits().then(console.log)\n   * => [ MultiReddit { ... }, MultiReddit { ... }, ... ]\n   */\n\n\n  getMyMultireddits() {\n    return this._get({\n      uri: 'api/multi/mine',\n      qs: {\n        expand_srs: true\n      }\n    });\n  }\n  /**\n   * @summary Creates a new multireddit.\n   * @param {object} options\n   * @param {string} options.name The name of the new multireddit. 50 characters max\n   * @param {string} options.description A description for the new multireddit, in markdown.\n   * @param {Array} options.subreddits An Array of Subreddit objects (or subreddit names) that this multireddit should compose of\n   * @param {string} [options.visibility='private'] The multireddit's visibility setting. One of `private`, `public`, `hidden`.\n   * @param {string} [options.icon_name=''] One of `art and design`, `ask`, `books`, `business`, `cars`, `comics`,\n   `cute animals`, `diy`, `entertainment`, `food and drink`, `funny`, `games`, `grooming`, `health`, `life advice`, `military`,\n   `models pinup`, `music`, `news`, `philosophy`, `pictures and gifs`, `science`, `shopping`, `sports`, `style`, `tech`,\n   `travel`, `unusual stories`, `video`, `None`\n   * @param {string} [options.key_color='#000000'] A six-digit RGB hex color, preceded by '#'\n   * @param {string} [options.weighting_scheme='classic'] One of `classic`, `fresh`\n   * @returns {Promise} A Promise for the newly-created MultiReddit object\n   * @example\n   *\n   * r.createMultireddit({\n   *   name: 'myMulti',\n   *   description: 'An example multireddit',\n   *   subreddits: ['snoowrap', 'snoowrap_testing']\n   * }).then(console.log)\n   * => MultiReddit { display_name: 'myMulti', ... }\n   */\n\n\n  createMultireddit(_ref13) {\n    var name = _ref13.name,\n        description = _ref13.description,\n        subreddits = _ref13.subreddits,\n        _ref13$visibility = _ref13.visibility,\n        visibility = _ref13$visibility === void 0 ? 'private' : _ref13$visibility,\n        _ref13$icon_name = _ref13.icon_name,\n        icon_name = _ref13$icon_name === void 0 ? '' : _ref13$icon_name,\n        _ref13$key_color = _ref13.key_color,\n        key_color = _ref13$key_color === void 0 ? '#000000' : _ref13$key_color,\n        _ref13$weighting_sche = _ref13.weighting_scheme,\n        weighting_scheme = _ref13$weighting_sche === void 0 ? 'classic' : _ref13$weighting_sche;\n    return this._post({\n      uri: 'api/multi',\n      form: {\n        model: JSON.stringify({\n          display_name: name,\n          description_md: description,\n          icon_name,\n          key_color,\n          subreddits: subreddits.map(function (sub) {\n            return {\n              name: typeof sub === 'string' ? sub : sub.display_name\n            };\n          }),\n          visibility,\n          weighting_scheme\n        })\n      }\n    });\n  }\n\n  _revokeToken(token) {\n    return this.credentialedClientRequest({\n      uri: 'api/v1/revoke_token',\n      form: {\n        token\n      },\n      method: 'post'\n    });\n  }\n  /**\n   * @summary Invalidates the current access token.\n   * @returns {Promise} A Promise that fulfills when this request is complete\n   * @desc **Note**: This can only be used if the current requester was supplied with a `client_id` and `client_secret`. If the\n   current requester was supplied with a refresh token, it will automatically create a new access token if any more requests\n   are made after this one.\n   * @example r.revokeAccessToken();\n   */\n\n\n  revokeAccessToken() {\n    var _this12 = this;\n\n    return this._revokeToken(this.accessToken).then(function () {\n      _this12.accessToken = null;\n      _this12.tokenExpiration = null;\n    });\n  }\n  /**\n   * @summary Invalidates the current refresh token.\n   * @returns {Promise} A Promise that fulfills when this request is complete\n   * @desc **Note**: This can only be used if the current requester was supplied with a `client_id` and `client_secret`. All\n   access tokens generated by this refresh token will also be invalidated. This effectively de-authenticates the requester and\n   prevents it from making any more valid requests. This should only be used in a few cases, e.g. if this token has\n   been accidentally leaked to a third party.\n   * @example r.revokeRefreshToken();\n   */\n\n\n  revokeRefreshToken() {\n    var _this13 = this;\n\n    return this._revokeToken(this.refreshToken).then(function () {\n      _this13.refreshToken = null;\n      _this13.accessToken = null; // Revoking a refresh token also revokes any associated access tokens.\n\n      _this13.tokenExpiration = null;\n    });\n  }\n\n  _selectFlair(_ref14) {\n    var _this14 = this;\n\n    var flair_template_id = _ref14.flair_template_id,\n        link = _ref14.link,\n        name = _ref14.name,\n        text = _ref14.text,\n        subredditName = _ref14.subredditName;\n\n    if (!flair_template_id) {\n      throw new errors.InvalidMethodCallError('No flair template ID provided');\n    }\n\n    return _Promise.default.resolve(subredditName).then(function (subName) {\n      return _this14._post({\n        uri: \"r/\".concat(subName, \"/api/selectflair\"),\n        form: {\n          api_type,\n          flair_template_id,\n          link,\n          name,\n          text\n        }\n      });\n    });\n  }\n\n  _assignFlair(_ref15) {\n    var _this15 = this;\n\n    var css_class = _ref15.css_class,\n        _ref15$cssClass = _ref15.cssClass,\n        cssClass = _ref15$cssClass === void 0 ? css_class : _ref15$cssClass,\n        link = _ref15.link,\n        name = _ref15.name,\n        text = _ref15.text,\n        subreddit_name = _ref15.subreddit_name,\n        _ref15$subredditName = _ref15.subredditName,\n        subredditName = _ref15$subredditName === void 0 ? subreddit_name : _ref15$subredditName;\n    return this._promiseWrap(_Promise.default.resolve(subredditName).then(function (displayName) {\n      return _this15._post({\n        uri: \"r/\".concat(displayName, \"/api/flair\"),\n        form: {\n          api_type,\n          name,\n          text,\n          link,\n          css_class: cssClass\n        }\n      });\n    }));\n  }\n\n  _populate(responseTree) {\n    var _this16 = this;\n\n    if (typeof responseTree === 'object' && responseTree !== null) {\n      // Map {kind: 't2', data: {name: 'some_username', ... }} to a RedditUser (e.g.) with the same properties\n      if (Object.keys(responseTree).length === 2 && responseTree.kind && responseTree.data) {\n        return this._newObject(_constants.KINDS[responseTree.kind] || 'RedditContent', this._populate(responseTree.data), true);\n      }\n\n      var result = (Array.isArray(responseTree) ? _lodash.map : _lodash.mapValues)(responseTree, function (value, key) {\n        // Maps {author: 'some_username'} to {author: RedditUser { name: 'some_username' } }\n        if (value !== null && _constants.USER_KEYS.has(key)) {\n          return _this16._newObject('RedditUser', {\n            name: value\n          });\n        }\n\n        if (value !== null && _constants.SUBREDDIT_KEYS.has(key)) {\n          return _this16._newObject('Subreddit', {\n            display_name: value\n          });\n        }\n\n        return _this16._populate(value);\n      });\n\n      if (result.length === 2 && result[0] instanceof snoowrap.objects.Listing && result[0][0] instanceof snoowrap.objects.Submission && result[1] instanceof snoowrap.objects.Listing) {\n        if (result[1]._more && !result[1]._more.link_id) {\n          result[1]._more.link_id = result[0][0].name;\n        }\n\n        result[0][0].comments = result[1];\n        return result[0][0];\n      }\n\n      return result;\n    }\n\n    return responseTree;\n  }\n\n  _getListing(_ref16) {\n    var uri = _ref16.uri,\n        _ref16$qs = _ref16.qs,\n        qs = _ref16$qs === void 0 ? {} : _ref16$qs,\n        options = _objectWithoutProperties(_ref16, [\"uri\", \"qs\"]);\n\n    /* When the response type is expected to be a Listing, add a `count` parameter with a very high number.\n    This ensures that reddit returns a `before` property in the resulting Listing to enable pagination.\n    (Aside from the additional parameter, this function is equivalent to snoowrap.prototype._get) */\n    var mergedQuery = _objectSpread({\n      count: 9999\n    }, qs);\n\n    return qs.limit || !(0, _lodash.isEmpty)(options) ? this._newObject('Listing', _objectSpread({\n      _query: mergedQuery,\n      _uri: uri\n    }, options)).fetchMore(qs.limit || _constants.MAX_LISTING_ITEMS)\n    /* This second case is used as a fallback in case the endpoint unexpectedly ends up returning something other than a\n    Listing (e.g. Submission#getRelated, which used to return a Listing but no longer does due to upstream reddit API\n    changes), in which case using fetch_more() as above will throw an error.\n     This fallback only works if there are no other meta-properties provided for the Listing, such as _transform. If there are\n    other meta-properties,  the function will still end up throwing an error, but there's not really any good way to handle it\n    (predicting upstream changes can only go so far). More importantly, in the limited cases where it's used, the fallback\n    should have no effect on the returned results */\n    : this._get({\n      uri,\n      qs: mergedQuery\n    }).then(function (listing) {\n      if (Array.isArray(listing)) {\n        listing.filter(function (item) {\n          return item.constructor._name === 'Comment';\n        }).forEach(_helpers.addEmptyRepliesListing);\n      }\n\n      return listing;\n    });\n  }\n  /**\n   * @summary In browsers, restores the `window.snoowrap` property to whatever it was before this instance of snoowrap was\n   loaded. This is a no-op in Node.\n   * @returns This instance of the snoowrap constructor\n   * @example var snoowrap = window.snoowrap.noConflict();\n   */\n\n\n  static noConflict() {\n    if (_helpers.isBrowser) {\n      global[_constants.MODULE_NAME] = this._previousSnoowrap;\n    }\n\n    return this;\n  }\n\n};\n\nfunction identity(value) {\n  return value;\n}\n\n(0, _helpers.defineInspectFunc)(snoowrap.prototype, function () {\n  // Hide confidential information (tokens, client IDs, etc.), as well as private properties, from the console.log output.\n  var keysForHiddenValues = ['clientSecret', 'refreshToken', 'accessToken', 'password'];\n  var formatted = (0, _lodash.mapValues)((0, _lodash.omitBy)(this, function (value, key) {\n    return typeof key === 'string' && key.startsWith('_');\n  }), function (value, key) {\n    return (0, _lodash.includes)(keysForHiddenValues, key) ? value && '(redacted)' : value;\n  });\n  return \"\".concat(_constants.MODULE_NAME, \" \").concat(_util.default.inspect(formatted));\n});\nvar classFuncDescriptors = {\n  configurable: true,\n  writable: true\n};\n/* Add the request_handler functions (oauth_request, credentialed_client_request, etc.) to the snoowrap prototype. Use\nObject.defineProperties to ensure that the properties are non-enumerable. */\n\nObject.defineProperties(snoowrap.prototype, (0, _lodash.mapValues)(requestHandler, function (func) {\n  return _objectSpread({\n    value: func\n  }, classFuncDescriptors);\n}));\n\n_constants.HTTP_VERBS.forEach(function (method) {\n  /* Define method shortcuts for each of the HTTP verbs. i.e. `snoowrap.prototype._post` is the same as `oauth_request` except\n  that the HTTP method defaults to `post`, and the result is promise-wrapped. Use Object.defineProperty to ensure that the\n  properties are non-enumerable. */\n  Object.defineProperty(snoowrap.prototype, \"_\".concat(method), _objectSpread({\n    value(options) {\n      return this._promiseWrap(this.oauthRequest(_objectSpread({}, options, {\n        method\n      })));\n    }\n\n  }, classFuncDescriptors));\n});\n/* `objects` will be an object containing getters for each content type, due to the way objects are exported from\nobjects/index.js. To unwrap these getters into direct properties, use lodash.mapValues with an identity function. */\n\n\nsnoowrap.objects = (0, _lodash.mapValues)(objects, function (value) {\n  return value;\n});\n(0, _lodash.forOwn)(_constants.KINDS, function (value) {\n  snoowrap.objects[value] = snoowrap.objects[value] || class extends objects.RedditContent {};\n  Object.defineProperty(snoowrap.objects[value], '_name', {\n    value,\n    configurable: true\n  });\n}); // Alias all functions on snoowrap's prototype and snoowrap's object prototypes in snake_case.\n\n(0, _lodash.values)(snoowrap.objects).concat(snoowrap).map(function (func) {\n  return func.prototype;\n}).forEach(function (funcProto) {\n  Object.getOwnPropertyNames(funcProto).filter(function (name) {\n    return !name.startsWith('_') && name !== (0, _lodash.snakeCase)(name) && typeof funcProto[name] === 'function';\n  }).forEach(function (name) {\n    return Object.defineProperty(funcProto, (0, _lodash.snakeCase)(name), _objectSpread({\n      value: funcProto[name]\n    }, classFuncDescriptors));\n  });\n});\nsnoowrap.errors = errors;\nsnoowrap.version = _constants.VERSION;\n\nif (!module.parent && _helpers.isBrowser) {\n  // check if the code is being run in a browser through browserify, etc.\n  snoowrap._previousSnoowrap = global[_constants.MODULE_NAME];\n  global[_constants.MODULE_NAME] = snoowrap;\n}\n\nmodule.exports = snoowrap;"]},"metadata":{},"sourceType":"script"}